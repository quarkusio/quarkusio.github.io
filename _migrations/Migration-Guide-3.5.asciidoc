---
date: 2023-10-25
---
:toc:

== Config

=== Kubernetes Environment Variables

Environment variables set for Kubernetes-based extensions require configuration names to use upper case names separated by underscores as documented in the https://quarkus.io/guides/config-reference#environment-variables[Configuration Reference]. In previous releases, it was possible to use lowercase dotted names. This was accidental and never intended to work this way.

=== Config property values injected during static intialization phase

Quarkus collects the config property values injected in CDI beans during the static intialization phase.
The collected values are then compared with their runtime initialization counterparts and if a mismatch is detected the application startup fails.

How can it happen?
For example, let's have a CDI bean `org.acme.MyBean`.
`MyBean` injects a `@ConfigProperty` of name `foo` and is initialized during the native build.
The config property does not exist during the native build and so the default value `bar` is used.
But later, when the application is started the property is defined with a system property: `-Dfoo=baz`.
This would lead to inconsistent state and unexpected behavior.
Therefore, Quarkus would fail in this situation by default.

You can annotate an injected field/parameter with `@io.quarkus.runtime.annotations.StaticInitSafe` to mark the injected configuration object as safe to be initialized during the static intialization phase.

== Qute

A user tag is now executed as an _isolated_ template by default, i.e. without access to the context of the template that calls the tag.
If you need to change the default behavior and disable the isolation, just add `_isolated=false` or `_unisolated` argument to the call site. For example `{#itemDetail item showImage=true _isolated=false /}` or `{#itemDetail item showImage=true _unisolated /}`. See also https://github.com/quarkusio/quarkus/discussions/22285[the discussion] for more details.

`io.quarkus.qute.ResultNode` is now an abstract class (it was an interface). In general, the `ResultNode` should not be implemented by users but it's part of the public API.

The Qute API is built on top of `java.util.concurrent.CompletionStage`. Up to now, any implementation could be used in the API. Since Quarkus 3.5 only the `java.util.concurrent.CompletableFuture` and the internal `io.quarkus.qute.CompletedStage` are supported by default. The behavior can be changed with the system property `-Dquarkus.qute.unrestricted-completion-stage-support=true`.

== Dev Services

=== Microsoft SQL Server

The Microsoft SQL Server Dev Services have been upgraded to `2022-latest` (and `azure-sql-edge:latest` for Mx Macs).

You will need to adjust your `container-license-acceptance.txt` file accordingly.

== OpenTelemetry

=== `@AddingSpanAttributes` now available

Annotating a method in any CDI aware bean with the `io.opentelemetry.instrumentation.annotations.AddingSpanAttributes` will not create a new span but will add annotated method parameters to attributes in the current span.

If a method is annotated by mistake with `@AddingSpanAttributes` and `@WithSpan` annotations, the `@WithSpan` annotation will take precedence.

== OptaPlanner

The OptaPlanner extensions have been removed from the Quarkus Platform as they were not compatible anymore with the latest Quarkus versions.

We recommend you to migrate to the https://timefold.ai/[Timefold] Quarkus extensions (available in the tooling and on https://code.quarkus.io/). Timefold is a fork of OptaPlanner.