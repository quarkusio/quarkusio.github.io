<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>This guide demonstrates how your Quarkus application can utilize SmallRye Reactive Messaging to interact with Apache Kafka.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="prerequisites"><a class="anchor" href="#prerequisites"></a>Prerequisites</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Unresolved directive in kafka-reactive-getting-started.adoc - include::{includes}/prerequisites.adoc[]</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="architecture"><a class="anchor" href="#architecture"></a>Architecture</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In this guide, we are going to develop two applications communicating with Kafka.
The first application sends a <em>quote request</em> to Kafka and consumes Kafka messages from the <em>quote</em> topic.
The second application receives the <em>quote request</em> and sends a <em>quote</em> back.</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="kafka-qs-architecture.png" alt="Architecture">
</div>
</div>
<div class="paragraph">
<p>The first application, the <em>producer</em>, will let the user request some quotes over an HTTP endpoint.
For each quote request a random identifier is generated and returned to the user, to mark the quote request as <em>pending</em>.
At the same time, the generated request id is sent over a Kafka topic <code>quote-requests</code>.</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="kafka-qs-app-screenshot.png" alt="Producer App UI">
</div>
</div>
<div class="paragraph">
<p>The second application, the <em>processor</em>, will read from the <code>quote-requests</code> topic, put a random price to the quote, and send it to a Kafka topic named <code>quotes</code>.</p>
</div>
<div class="paragraph">
<p>Lastly, the <em>producer</em> will read the quotes and send them to the browser using server-sent events.
The user will therefore see the quote price updated from <em>pending</em> to the received price in real-time.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="solution"><a class="anchor" href="#solution"></a>Solution</h2>
<div class="sectionbody">
<div class="paragraph">
<p>We recommend that you follow the instructions in the next sections and create applications step by step.
However, you can go right to the completed example.</p>
</div>
<div class="paragraph">
<p>Clone the Git repository: <code>git clone <a href="https://github.com/quarkusio/quarkus-quickstarts.git" class="bare">https://github.com/quarkusio/quarkus-quickstarts.git</a></code>, or download an <a href="https://github.com/quarkusio/quarkus-quickstarts/archive/main.zip">archive</a>.</p>
</div>
<div class="paragraph">
<p>The solution is located in the <code>kafka-quickstart</code> <a href="https://github.com/quarkusio/quarkus-quickstarts/tree/main/kafka-quickstart">directory</a>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="creating-the-maven-project"><a class="anchor" href="#creating-the-maven-project"></a>Creating the Maven Project</h2>
<div class="sectionbody">
<div class="paragraph">
<p>First, we need to create two projects: the <em>producer</em> and the <em>processor</em>.</p>
</div>
<div class="paragraph">
<p>To create the <em>producer</em> project, in a terminal run:</p>
</div>
<div class="paragraph">
<p>Unresolved directive in kafka-reactive-getting-started.adoc - include::{includes}/devtools/create-app.adoc[]</p>
</div>
<div class="paragraph">
<p>This command creates the project structure and selects two Quarkus extensions we will be using:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>RESTEasy Reactive and its Jackson support (to handle JSON) to serve the HTTP endpoint.</p>
</li>
<li>
<p>The Kafka connector for Reactive Messaging</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>To create the <em>processor</em> project, from the same directory, run:</p>
</div>
<div class="paragraph">
<p>Unresolved directive in kafka-reactive-getting-started.adoc - include::{includes}/devtools/create-app.adoc[]</p>
</div>
<div class="paragraph">
<p>At that point, you should have the following structure:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">.
├── kafka-quickstart-processor
│  ├── README.md
│  ├── mvnw
│  ├── mvnw.cmd
│  ├── pom.xml
│  └── src
│     └── main
│        ├── docker
│        ├── java
│        └── resources
│           └── application.properties
└── kafka-quickstart-producer
   ├── README.md
   ├── mvnw
   ├── mvnw.cmd
   ├── pom.xml
   └── src
      └── main
         ├── docker
         ├── java
         └── resources
            └── application.properties</code></pre>
</div>
</div>
<div class="paragraph">
<p>Open the two projects in your favorite IDE.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="title">Dev Services</div>
<div class="paragraph">
<p>No need to start a Kafka broker when using the dev mode or for tests.
Quarkus starts a broker for you automatically.
See <a href="kafka-dev-services">Dev Services for Kafka</a> for details.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="the-quote-object"><a class="anchor" href="#the-quote-object"></a>The Quote object</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The <code>Quote</code> class will be used in both <em>producer</em> and <em>processor</em> projects.
For the sake of simplicity, we will duplicate the class.
In both projects, create the <code>src/main/java/org/acme/kafka/model/Quote.java</code> file, with the following content:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.acme.kafka.model;

public class Quote {

    public String id;
    public int price;

    /**
    * Default constructor required for Jackson serializer
    */
    public Quote() { }

    public Quote(String id, int price) {
        this.id = id;
        this.price = price;
    }

    @Override
    public String toString() {
        return "Quote{" +
                "id='" + id + '\'' +
                ", price=" + price +
                '}';
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>JSON representation of <code>Quote</code> objects will be used in messages sent to the Kafka topic
and also in the server-sent events sent to web browsers.</p>
</div>
<div class="paragraph">
<p>Quarkus has built-in capabilities to deal with JSON Kafka messages.
In a following section, we will create serializer/deserializer classes for Jackson.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sending-quote-request"><a class="anchor" href="#sending-quote-request"></a>Sending quote request</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Inside the <em>producer</em> project, create the <code>src/main/java/org/acme/kafka/producer/QuotesResource.java</code> file and add the following content:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.acme.kafka.producer;

import java.util.UUID;

import jakarta.ws.rs.GET;
import jakarta.ws.rs.POST;
import jakarta.ws.rs.Path;
import jakarta.ws.rs.Produces;
import jakarta.ws.rs.core.MediaType;

import org.acme.kafka.model.Quote;
import org.eclipse.microprofile.reactive.messaging.Channel;
import org.eclipse.microprofile.reactive.messaging.Emitter;

@Path("/quotes")
public class QuotesResource {

    @Channel("quote-requests")
    Emitter&lt;String&gt; quoteRequestEmitter; <i class="conum" data-value="1"></i><b>(1)</b>

    /**
     * Endpoint to generate a new quote request id and send it to "quote-requests" Kafka topic using the emitter.
     */
    @POST
    @Path("/request")
    @Produces(MediaType.TEXT_PLAIN)
    public String createRequest() {
        UUID uuid = UUID.randomUUID();
        quoteRequestEmitter.send(uuid.toString()); <i class="conum" data-value="2"></i><b>(2)</b>
        return uuid.toString(); <i class="conum" data-value="3"></i><b>(3)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Inject a Reactive Messaging <code>Emitter</code> to send messages to the <code>quote-requests</code> channel.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>On a post request, generate a random UUID and send it to the Kafka topic using the emitter.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Return the same UUID to the client.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The <code>quote-requests</code> channel is going to be managed as a Kafka topic, as that&#8217;s the only connector on the classpath.
If not indicated otherwise, like in this example, Quarkus uses the channel name as topic name.
So, in this example, the application writes into the <code>quote-requests</code> topic.
Quarkus also configures the serializer automatically, because it finds that the <code>Emitter</code> produces <code>String</code> values.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
When you have multiple connectors, you would need to indicate which connector you want to use in the application configuration.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="processing-quote-requests"><a class="anchor" href="#processing-quote-requests"></a>Processing quote requests</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Now let&#8217;s consume the quote request and give out a price.
Inside the <em>processor</em> project, create the <code>src/main/java/org/acme/kafka/processor/QuotesProcessor.java</code> file and add the following content:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.acme.kafka.processor;

import java.util.Random;

import jakarta.enterprise.context.ApplicationScoped;

import org.acme.kafka.model.Quote;
import org.eclipse.microprofile.reactive.messaging.Incoming;
import org.eclipse.microprofile.reactive.messaging.Outgoing;

import io.smallrye.reactive.messaging.annotations.Blocking;

/**
 * A bean consuming data from the "quote-requests" Kafka topic (mapped to "requests" channel) and giving out a random quote.
 * The result is pushed to the "quotes" Kafka topic.
 */
@ApplicationScoped
public class QuotesProcessor {

    private Random random = new Random();

    @Incoming("requests") <i class="conum" data-value="1"></i><b>(1)</b>
    @Outgoing("quotes")   <i class="conum" data-value="2"></i><b>(2)</b>
    @Blocking             <i class="conum" data-value="3"></i><b>(3)</b>
    public Quote process(String quoteRequest) throws InterruptedException {
        // simulate some hard working task
        Thread.sleep(200);
        return new Quote(quoteRequest, random.nextInt(100));
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Indicates that the method consumes the items from the <code>requests</code> channel.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Indicates that the objects returned by the method are sent to the <code>quotes</code> channel.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Indicates that the processing is <em>blocking</em> and cannot be run on the caller thread.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>For every Kafka <em>record</em> from the <code>quote-requests</code> topic, Reactive Messaging calls the <code>process</code> method, and sends the returned <code>Quote</code> object to the <code>quotes</code> channel.
In this case, we need to configure the channel in the <code>application.properties</code> file, to configures the <code>requests</code> and <code>quotes</code> channels:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">%dev.quarkus.http.port=8081

# Configure the incoming `quote-requests` Kafka topic
mp.messaging.incoming.requests.topic=quote-requests
mp.messaging.incoming.requests.auto.offset.reset=earliest</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that in this case we have one incoming and one outgoing connector configuration, each one distinctly named.
The configuration keys are structured as follows:</p>
</div>
<div class="paragraph">
<p><code>mp.messaging.[outgoing|incoming].{channel-name}.property=value</code></p>
</div>
<div class="paragraph">
<p>The <code>channel-name</code> segment must match the value set in the <code>@Incoming</code> and <code>@Outgoing</code> annotation:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>quote-requests</code> &#8594; Kafka topic from which we read the quote requests</p>
</li>
<li>
<p><code>quotes</code> &#8594; Kafka topic in which we write the quotes</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>More details about this configuration is available on the <a href="https://kafka.apache.org/documentation/#producerconfigs">Producer configuration</a> and <a href="https://kafka.apache.org/documentation/#consumerconfigs">Consumer configuration</a> section from the Kafka documentation. These properties are configured with the prefix <code>kafka</code>.
An exhaustive list of configuration properties is available in <a href="kafka#kafka-configuration">Kafka Reference Guide - Configuration</a>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>mp.messaging.incoming.requests.auto.offset.reset=earliest</code> instructs the application to start reading the topics from the first offset, when there is no committed offset for the consumer group.
In other words, it will also process messages sent before we start the processor application.</p>
</div>
<div class="paragraph">
<p>There is no need to set serializers or deserializers.
Quarkus detects them, and if none are found, generates them using JSON serialization.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="receiving-quotes"><a class="anchor" href="#receiving-quotes"></a>Receiving quotes</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Back to our <em>producer</em> project.
Let&#8217;s modify the <code>QuotesResource</code> to consume quotes from Kafka and send them back to the client via Server-Sent Events:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import io.smallrye.mutiny.Multi;

...

@Channel("quotes")
Multi&lt;Quote&gt; quotes; <i class="conum" data-value="1"></i><b>(1)</b>

/**
 * Endpoint retrieving the "quotes" Kafka topic and sending the items to a server sent event.
 */
@GET
@Produces(MediaType.SERVER_SENT_EVENTS) <i class="conum" data-value="2"></i><b>(2)</b>
public Multi&lt;Quote&gt; stream() {
    return quotes; <i class="conum" data-value="3"></i><b>(3)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Injects the <code>quotes</code> channel using the <code>@Channel</code> qualifier</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Indicates that the content is sent using <code>Server Sent Events</code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Returns the stream (<em>Reactive Stream</em>)</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>No need to configure anything, as Quarkus will automatically associate the <code>quotes</code> channel to the <code>quotes</code> Kafka topic.
It will also generate a deserializer for the <code>Quote</code> class.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<div class="title">Message serialization in Kafka</div>
<p>In this example we used Jackson to serialize/deserialize Kafka messages.
For more options on message serialization, see <a href="kafka#kafka-serialization">Kafka Reference Guide - Serialization</a>.</p>
</div>
<div class="paragraph">
<p>We strongly suggest adopting a contract-first approach using a schema registry.
To learn more about how to use Apache Kafka with the schema registry and Avro, follow the
<a href="kafka-schema-registry-avro">Using Apache Kafka with Schema Registry and Avro</a> guide.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="the-html-page"><a class="anchor" href="#the-html-page"></a>The HTML page</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Final touch, the HTML page requesting quotes and displaying the prices obtained over SSE.</p>
</div>
<div class="paragraph">
<p>Inside the <em>producer</em> project, create the <code>src/main/resources/META-INF/resources/quotes.html</code> file with the following content:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;Prices&lt;/title&gt;

    &lt;link rel="stylesheet" type="text/css"
          href="https://cdnjs.cloudflare.com/ajax/libs/patternfly/3.24.0/css/patternfly.min.css"&gt;
    &lt;link rel="stylesheet" type="text/css"
          href="https://cdnjs.cloudflare.com/ajax/libs/patternfly/3.24.0/css/patternfly-additions.min.css"&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div class="container"&gt;
    &lt;div class="card"&gt;
        &lt;div class="card-body"&gt;
            &lt;h2 class="card-title"&gt;Quotes&lt;/h2&gt;
            &lt;button class="btn btn-info" id="request-quote"&gt;Request Quote&lt;/button&gt;
            &lt;div class="quotes"&gt;&lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
&lt;/body&gt;
&lt;script src="https://code.jquery.com/jquery-3.6.0.min.js"&gt;&lt;/script&gt;
&lt;script&gt;
    $("#request-quote").click((event) =&gt; {
        fetch("/quotes/request", {method: "POST"})
        .then(res =&gt; res.text())
        .then(qid =&gt; {
            var row = $(`&lt;h4 class='col-md-12' id='${qid}'&gt;Quote # &lt;i&gt;${qid}&lt;/i&gt; | &lt;strong&gt;Pending&lt;/strong&gt;&lt;/h4&gt;`);
            $(".quotes").prepend(row);
        });
    });

    var source = new EventSource("/quotes");
    source.onmessage = (event) =&gt; {
      var json = JSON.parse(event.data);
      $(`#${json.id}`).html((index, html) =&gt; {
        return html.replace("Pending", `\$\xA0${json.price}`);
      });
    };
&lt;/script&gt;
&lt;/html&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Nothing spectacular here.
When the user clicks the button, HTTP request is made to request a quote, and a pending quote is added to the list.
On each quote received over SSE, the corresponding item in the list is updated.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="get-it-running"><a class="anchor" href="#get-it-running"></a>Get it running</h2>
<div class="sectionbody">
<div class="paragraph">
<p>You just need to run both applications.
In one terminal, run:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">mvn -f producer quarkus:dev</code></pre>
</div>
</div>
<div class="paragraph">
<p>In another terminal, run:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">mvn -f processor quarkus:dev</code></pre>
</div>
</div>
<div class="paragraph">
<p>Quarkus starts a Kafka broker automatically, configures the application and shares the Kafka broker instance between different applications.
See <a href="kafka-dev-services">Dev Services for Kafka</a> for more details.</p>
</div>
<div class="paragraph">
<p>Open <code><a href="http://localhost:8080/quotes.html" class="bare">http://localhost:8080/quotes.html</a></code> in your browser and request some quotes by clicking the button.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="running-in-jvm-or-native-mode"><a class="anchor" href="#running-in-jvm-or-native-mode"></a>Running in JVM or Native mode</h2>
<div class="sectionbody">
<div class="paragraph">
<p>When not running in dev or test mode, you will need to start your Kafka broker.
You can follow the instructions from the <a href="https://kafka.apache.org/quickstart">Apache Kafka website</a> or create a <code>docker-compose.yaml</code> file with the following content:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">version: '3.5'

services:

  zookeeper:
    image: quay.io/strimzi/kafka:0.23.0-kafka-2.8.0
    command: [
      "sh", "-c",
      "bin/zookeeper-server-start.sh config/zookeeper.properties"
    ]
    ports:
      - "2181:2181"
    environment:
      LOG_DIR: /tmp/logs
    networks:
      - kafka-quickstart-network

  kafka:
    image: quay.io/strimzi/kafka:0.23.0-kafka-2.8.0
    command: [
      "sh", "-c",
      "bin/kafka-server-start.sh config/server.properties --override listeners=$${KAFKA_LISTENERS} --override advertised.listeners=$${KAFKA_ADVERTISED_LISTENERS} --override zookeeper.connect=$${KAFKA_ZOOKEEPER_CONNECT}"
    ]
    depends_on:
      - zookeeper
    ports:
      - "9092:9092"
    environment:
      LOG_DIR: "/tmp/logs"
      KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://kafka:9092
      KAFKA_LISTENERS: PLAINTEXT://0.0.0.0:9092
      KAFKA_ZOOKEEPER_CONNECT: zookeeper:2181
    networks:
      - kafka-quickstart-network

  producer:
    image: quarkus-quickstarts/kafka-quickstart-producer:1.0-${QUARKUS_MODE:-jvm}
    build:
      context: producer
      dockerfile: src/main/docker/Dockerfile.${QUARKUS_MODE:-jvm}
    depends_on:
      - kafka
    environment:
      KAFKA_BOOTSTRAP_SERVERS: kafka:9092
    ports:
      - "8080:8080"
    networks:
      - kafka-quickstart-network

  processor:
    image: quarkus-quickstarts/kafka-quickstart-processor:1.0-${QUARKUS_MODE:-jvm}
    build:
      context: processor
      dockerfile: src/main/docker/Dockerfile.${QUARKUS_MODE:-jvm}
    depends_on:
      - kafka
    environment:
      KAFKA_BOOTSTRAP_SERVERS: kafka:9092
    networks:
      - kafka-quickstart-network

networks:
  kafka-quickstart-network:
    name: kafkaquickstart</code></pre>
</div>
</div>
<div class="paragraph">
<p>Make sure you first build both applications in JVM mode with:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">mvn -f producer package
mvn -f processor package</code></pre>
</div>
</div>
<div class="paragraph">
<p>Once packaged, run <code>docker-compose up</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
This is a development cluster, do not use in production.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>You can also build and run our applications as native executables.
First, compile both applications as native:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">mvn -f producer package -Dnative -Dquarkus.native.container-build=true
mvn -f processor package -Dnative -Dquarkus.native.container-build=true</code></pre>
</div>
</div>
<div class="paragraph">
<p>Run the system with:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">export QUARKUS_MODE=native
docker-compose up --build</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="going-further"><a class="anchor" href="#going-further"></a>Going further</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This guide has shown how you can interact with Kafka using Quarkus.
It utilizes <a href="https://smallrye.io/smallrye-reactive-messaging">SmallRye Reactive Messaging</a> to build data streaming applications.</p>
</div>
<div class="paragraph">
<p>For the exhaustive list of features and configuration options, check the <a href="kafka">Reference guide for Apache Kafka Extension</a>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>In this guide we explore Smallrye Reactive Messaging framework to interact with Apache Kafka.
Quarkus extension for Kafka also allows
<a href="kafka#kafka-bare-clients">using Kafka clients directly</a>.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>