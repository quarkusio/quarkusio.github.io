<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>Quarkus includes the <code>kubernetes-client</code> extension which enables the use of the <a href="https://github.com/fabric8io/kubernetes-client">Fabric8 Kubernetes Client</a>
in native mode while also making it easier to work with.</p>
</div>
<div class="paragraph">
<p>Having a Kubernetes Client extension in Quarkus is very useful in order to unlock the power of Kubernetes Operators.
Kubernetes Operators are quickly emerging as a new class of Cloud Native applications.
These applications essentially watch the Kubernetes API and react to changes on various resources and can be used to manage the lifecycle of all kinds of complex systems like databases, messaging systems and much more.
Being able to write such operators in Java with the very low footprint that native images provide is a great match.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="configuration"><a class="anchor" href="#configuration"></a>Configuration</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Once you have your Quarkus project configured you can add the <code>kubernetes-client</code> extension
to your project by running the following command in your project base directory.</p>
</div>
<div class="paragraph">
<p>Unresolved directive in kubernetes-client.adoc - include::{includes}/devtools/extension-add.adoc[]</p>
</div>
<div class="paragraph">
<p>This will add the following to your build file:</p>
</div>
<div class="listingblock primary asciidoc-tabs-target-sync-cli asciidoc-tabs-target-sync-maven">
<div class="title">pom.xml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
    &lt;artifactId&gt;quarkus-kubernetes-client&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary asciidoc-tabs-target-sync-gradle">
<div class="title">build.gradle</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-gradle hljs" data-lang="gradle">implementation("io.quarkus:quarkus-kubernetes-client")</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="usage"><a class="anchor" href="#usage"></a>Usage</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Quarkus configures a Bean of type <code>KubernetesClient</code> which can be injected into application code using the well known CDI methods.
This client can be configured using various properties as can be seen in the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">quarkus.kubernetes-client.trust-certs=false
quarkus.kubernetes-client.namespace=default</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that the full list of properties is available in the <a href="#quarkus-kubernetes-client_quarkus.kubernetes-client.devservices-dev-services">Dev Services section of the configuration reference</a>.</p>
</div>
<div class="paragraph">
<p>In dev mode and when running tests, <a href="kubernetes-dev-services">Dev Services for Kubernetes</a> automatically starts a Kubernetes API server.</p>
</div>
<div class="sect2">
<h3 id="customizing-and-overriding"><a class="anchor" href="#customizing-and-overriding"></a>Customizing and overriding</h3>
<div class="paragraph">
<p>Quarkus provides multiple integration points for influencing the Kubernetes Client provided as a CDI bean.</p>
</div>
<div class="sect3">
<h4 id="kubernetes-client-config-customization"><a class="anchor" href="#kubernetes-client-config-customization"></a>Kubernetes Client Config customization</h4>
<div class="paragraph">
<p>The first integration point is the use of the <code>io.quarkus.kubernetes.client.KubernetesConfigCustomizer</code> interface. When such a bean exists,
it allows for arbitrary customizations of the <code>io.fabric8.kubernetes.client.Config</code> created by Quarkus (which takes into account the <code>quarkus.kubernetes-client.*</code> properties).</p>
</div>
<div class="paragraph">
<p>Alternatively, application code can override the  <code>io.fabric8.kubernetes.client.Config</code> or even the <code>io.fabric8.kubernetes.client.KubernetesClient</code> bean (which are
normally provided by the extension) by simply declaring custom versions of those beans.</p>
</div>
<div class="paragraph">
<p>An example of this can be seen in the following snippet:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Singleton
public class KubernetesClientProducer {

    @Produces
    public KubernetesClient kubernetesClient() {
        // here you would create a custom client
        return new DefaultKubernetesClient();
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="kubernetes-client-objectmapper-customization"><a class="anchor" href="#kubernetes-client-objectmapper-customization"></a>Kubernetes Client ObjectMapper customization</h4>
<div class="paragraph">
<p>The Fabric8 Kubernetes Client uses its own <code>ObjectMapper</code> instance for serialization and deserialization of Kubernetes resources.
This mapper is provided to the client through a <code>KubernetesSerialization</code> instance that&#8217;s injected into
the <code>KubernetesClient</code> bean.</p>
</div>
<div class="paragraph">
<p>If for some reason you must customize the default <code>ObjectMapper</code> bean provided by this extension and used by the Kubernetes Client, you can do so by declaring a bean that implements the <code>KubernetesClientObjectMapperCustomizer</code> interface.</p>
</div>
<div class="paragraph">
<p>The following code snippet contains an example of a <code>KubernetesClientObjectMapperCustomizer</code> to set the <code>ObjectMapper</code> locale:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Singleton
public static class Customizer implements KubernetesClientObjectMapperCustomizer {
    @Override
    public void customize(ObjectMapper objectMapper) {
        objectMapper.setLocale(Locale.ROOT);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Furthermore, if you must replace the default <code>ObjectMapper</code> bean used by the Kubernetes Client that the extension creates automatically, you can do so by declaring a bean of type <code>@KubernetesClientObjectMapper</code>.
The following code snippet shows how you can declare this bean:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Singleton
public class KubernetesObjectMapperProducer {
    @KubernetesClientObjectMapper
    @Singleton
    @Produces
    public ObjectMapper kubernetesClientObjectMapper() {
        return new ObjectMapper();
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
The static <code>io.fabric8.kubernetes.client.utils.Serialization</code> utils class is deprecated and should not be used.
Access to <code>Serialization.jsonMapper()</code> should be replaced by the usage of @KubernetesClientObjectMapperCustomizer` declared beans.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="testing"><a class="anchor" href="#testing"></a>Testing</h2>
<div class="sectionbody">
<div class="paragraph">
<p>To make testing against a mock Kubernetes API extremely simple, Quarkus provides the <code>WithKubernetesTestServer</code> annotation which automatically launches
a mock of the Kubernetes API server and sets the proper environment variables needed so that the Kubernetes Client configures itself to use said mock.
Tests can inject the mock server and set it up in any way necessary for the particular testing using the <code>@KubernetesTestServer</code> annotation.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s assume we have a REST endpoint defined like so:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">@Path("/pod")
public class Pods {

    private final KubernetesClient kubernetesClient;

    public Pods(KubernetesClient kubernetesClient) {
        this.kubernetesClient = kubernetesClient;
    }

    @GET
    @Path("/{namespace}")
    public List&lt;Pod&gt; pods(String namespace) {
        return kubernetesClient.pods().inNamespace(namespace).list().getItems();
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>We could write a test for this endpoint very easily like so:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">// you can even configure aspects like crud, https and port on this annotation
@WithKubernetesTestServer
@QuarkusTest
public class KubernetesClientTest {

    @KubernetesTestServer
    KubernetesServer mockServer;

    @BeforeEach
    public void before() {
        final Pod pod1 = new PodBuilder().withNewMetadata().withName("pod1").withNamespace("test").and().build();
        final Pod pod2 = new PodBuilder().withNewMetadata().withName("pod2").withNamespace("test").and().build();

        // Set up Kubernetes so that our "pretend" pods are created
        mockServer.getClient().pods().create(pod1);
        mockServer.getClient().pods().create(pod2);
    }

    @Test
    public void testInteractionWithAPIServer() {
        RestAssured.when().get("/pod/test").then()
                .body("size()", is(2));
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that to take advantage of these features, the <code>quarkus-test-kubernetes-client</code> dependency needs to be added, for example like so:</p>
</div>
<div class="listingblock primary asciidoc-tabs-target-sync-cli asciidoc-tabs-target-sync-maven">
<div class="title">pom.xml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
    &lt;artifactId&gt;quarkus-test-kubernetes-client&lt;/artifactId&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary asciidoc-tabs-target-sync-gradle">
<div class="title">build.gradle</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-gradle hljs" data-lang="gradle">testImplementation("io.quarkus:quarkus-test-kubernetes-client")</code></pre>
</div>
</div>
<div class="paragraph">
<p>By default, the mock server will be in CRUD mode, so you have to use the client to build your state before your application can retrieve it,
but you can also set it up in non-CRUD mode and mock all HTTP requests made to Kubernetes:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">// you can even configure aspects like crud, https and port on this annotation
@WithKubernetesTestServer(crud = false)
@QuarkusTest
public class KubernetesClientTest {

    @KubernetesTestServer
    KubernetesServer mockServer;

    @BeforeEach
    public void before() {
        final Pod pod1 = new PodBuilder().withNewMetadata().withName("pod1").withNamespace("test").and().build();
        final Pod pod2 = new PodBuilder().withNewMetadata().withName("pod2").withNamespace("test").and().build();

        // Mock any HTTP request to Kubernetes pods so that our pods are returned
        mockServer.expect().get().withPath("/api/v1/namespaces/test/pods")
                .andReturn(200,
                        new PodListBuilder().withNewMetadata().withResourceVersion("1").endMetadata().withItems(pod1, pod2)
                                .build())
                .always();
    }

    @Test
    public void testInteractionWithAPIServer() {
        RestAssured.when().get("/pod/test").then()
                .body("size()", is(2));
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can also use the <code>setup</code> attribute on the <code>@WithKubernetesTestServer</code> annotation to provide a class that will configure the <code>KubernetesServer</code> instance:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">@WithKubernetesTestServer(setup = MyTest.Setup.class)
@QuarkusTest
public class MyTest {

    public static class Setup implements Consumer&lt;KubernetesServer&gt; {

        @Override
        public void accept(KubernetesServer server) {
          server.expect().get().withPath("/api/v1/namespaces/test/pods")
            .andReturn(200, new PodList()).always();
        }
    }

    // tests
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Alternately, you can create an extension of the <code>KubernetesServerTestResource</code> class to ensure all your <code>@QuarkusTest</code> enabled test classes share the same mock server setup via the <code>QuarkusTestResource</code> annotation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">public class CustomKubernetesMockServerTestResource extends KubernetesServerTestResource {

    @Override
    protected void configureServer() {
        super.configureServer();
        server.expect().get().withPath("/api/v1/namespaces/test/pods")
          .andReturn(200, new PodList()).always();
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>and use this in your other test classes as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">@QuarkusTestResource(CustomKubernetesMockServerTestResource.class)
@QuarkusTest
public class KubernetesClientTest {

    //tests will now use the configured server...
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="note-on-generic-types"><a class="anchor" href="#note-on-generic-types"></a>Note on implementing or extending generic types</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Due to the restrictions imposed by GraalVM, extra care needs to be taken when implementing or extending generic types provided by the client if the application is intended to work in native mode.
Essentially every implementation or extension of generic classes such as <code>Watcher</code>, <code>ResourceHandler</code> or <code>CustomResource</code> needs to specify their associated Kubernetes model class (or, in the case of <code>CustomResource</code>, regular Java types) at class definition time.
To better understand this, suppose we want to watch for changes to Kubernetes <code>Pod</code> resources.
There are a couple ways to write such a <code>Watcher</code> that are guaranteed to work in native:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">client.pods().watch(new Watcher&lt;Pod&gt;() {
    @Override
    public void eventReceived(Action action, Pod pod) {
        // do something
    }

    @Override
    public void onClose(KubernetesClientException e) {
        // do something
    }
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>or</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">public class PodResourceWatcher implements Watcher&lt;Pod&gt; {
    @Override
    public void eventReceived(Action action, Pod pod) {
        // do something
    }

    @Override
    public void onClose(KubernetesClientException e) {
        // do something
    }
}

...


client.pods().watch(new PodResourceWatcher());</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that defining the generic type via a class hierarchy similar to the following example will also work correctly:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">public abstract class MyWatcher&lt;S&gt; implements Watcher&lt;S&gt; {
}

...


client.pods().watch(new MyWatcher&lt;Pod&gt;() {
    @Override
    public void eventReceived(Action action, Pod pod) {
        // do something
    }
});</code></pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
The following example will <strong>not</strong> work in native mode because the generic type of watcher cannot be determined by looking at the class and method definitions
thus making Quarkus unable to properly determine the Kubernetes model class for which reflection registration is needed:
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">public class ResourceWatcher&lt;T extends HasMetadata&gt; implements Watcher&lt;T&gt; {
    @Override
    public void eventReceived(Action action, T resource) {
        // do something
    }

    @Override
    public void onClose(KubernetesClientException e) {
        // do something
    }
}

client.pods().watch(new ResourceWatcher&lt;Pod&gt;());</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="note-on-ec-keys"><a class="anchor" href="#note-on-ec-keys"></a>Note on using Elliptic Curve keys</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Please note that if you would like to use Elliptic Curve keys with Kubernetes Client then adding a BouncyCastle PKIX dependency is required:</p>
</div>
<div class="listingblock primary asciidoc-tabs-target-sync-cli asciidoc-tabs-target-sync-maven">
<div class="title">pom.xml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.bouncycastle&lt;/groupId&gt;
    &lt;artifactId&gt;bcpkix-jdk18on&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary asciidoc-tabs-target-sync-gradle">
<div class="title">build.gradle</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-gradle hljs" data-lang="gradle">implementation("org.bouncycastle:bcpkix-jdk18on")</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that internally an <code>org.bouncycastle.jce.provider.BouncyCastleProvider</code> provider will be registered if it has not already been registered.</p>
</div>
<div class="paragraph">
<p>You can have this provider registered as described in the <a href="security-customization#bouncy-castle">BouncyCastle</a> or <a href="security-customization#bouncy-castle-fips">BouncyCastle FIPS</a> sections.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="access-to-the-kubernetes-api"><a class="anchor" href="#access-to-the-kubernetes-api"></a>Access to the Kubernetes API</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In many cases in order to access the Kubernetes API server a <code>ServiceAccount</code>, <code>Role</code> and <code>RoleBinding</code> will be necessary.
An example that allows listing all pods could look something like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: &lt;applicationName&gt;
  namespace: &lt;namespace&gt;
---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: &lt;applicationName&gt;
  namespace: &lt;namespace&gt;
rules:
  - apiGroups: [""]
    resources: ["pods"]
    verbs: ["list"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: &lt;applicationName&gt;
  namespace: &lt;namespace&gt;
roleRef:
  kind: Role
  name: &lt;applicationName&gt;
  apiGroup: rbac.authorization.k8s.io
subjects:
  - kind: ServiceAccount
    name: &lt;applicationName&gt;
    namespace: &lt;namespace&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Replace <code>&lt;applicationName&gt;</code> and <code>&lt;namespace&gt;</code> with your values.
Have a look at <a href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/">Configure Service Accounts for Pods</a> to get further information.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="openshift-client"><a class="anchor" href="#openshift-client"></a>OpenShift Client</h2>
<div class="sectionbody">
<div class="paragraph">
<p>If the targeted Kubernetes cluster is an OpenShift cluster, it is possible to access it through
the <code>openshift-client</code> extension, in a similar way. This leverages the dedicated fabric8
openshift client, and provides access to <code>OpenShift</code> proprietary objects (e.g. <code>Route</code>, <code>ProjectRequest</code>, <code>BuildConfig</code> &#8230;&#8203;)</p>
</div>
<div class="paragraph">
<p>Note that the configuration properties are shared with the <code>kubernetes-client</code> extension. In
particular, they have the same <code>quarkus.kubernetes-client</code> prefix.</p>
</div>
<div class="paragraph">
<p>Add the extension with:</p>
</div>
<div class="paragraph">
<p>Unresolved directive in kubernetes-client.adoc - include::{includes}/devtools/extension-add.adoc[]</p>
</div>
<div class="paragraph">
<p>Note that <code>openshift-client</code> extension has a dependency on the <code>kubernetes-client</code> extension.</p>
</div>
<div class="paragraph">
<p>To use the client, inject an <code>OpenShiftClient</code> instead of the <code>KubernetesClient</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Inject
private OpenShiftClient openshiftClient;</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you need to override the default <code>OpenShiftClient</code>, provide a producer such as:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Singleton
public class OpenShiftClientProducer {

    @Produces
    public OpenShiftClient openshiftClient() {
        // here you would create a custom client
        return new DefaultOpenShiftClient();
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Mock support is also provided in a similar fashion:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@QuarkusTestResource(OpenShiftMockServerTestResource.class)
@QuarkusTest
public class OpenShiftClientTest {

    @MockServer
    private OpenShiftMockServer mockServer;
...</code></pre>
</div>
</div>
<div class="paragraph">
<p>Or by using the <code>@WithOpenShiftTestServer</code> similar to the <code>@WithKubernetesTestServer</code> explained in the
previous section:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@WithOpenShiftTestServer
@QuarkusTest
public class OpenShiftClientTest {

    @OpenShiftTestServer
    private OpenShiftServer mockOpenShiftServer;
...</code></pre>
</div>
</div>
<div class="paragraph">
<p>To use this feature, you have to add a dependency on <code>quarkus-test-openshift-client</code>:</p>
</div>
<div class="listingblock primary asciidoc-tabs-target-sync-cli asciidoc-tabs-target-sync-maven">
<div class="title">pom.xml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
    &lt;artifactId&gt;quarkus-test-openshift-client&lt;/artifactId&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary asciidoc-tabs-target-sync-gradle">
<div class="title">build.gradle</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-gradle hljs" data-lang="gradle">testImplementation("io.quarkus:quarkus-test-openshift-client")</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="configuration-reference"><a class="anchor" href="#configuration-reference"></a>Configuration Reference</h2>
<div class="sectionbody">

</div>
</div>