<!DOCTYPE html>
<html lang="en">







<head>
  <title>OpenID Connect (OIDC) Bearer token authentication - Quarkus</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta http-equiv="Content-Security-Policy" content="
  connect-src 'self' https://dpm.demdex.net https://adobedc.demdex.net https://route-default-test-mscherer-matamo.apps.ospo-osci.z3b1.p1.openshiftapps.com/ https://search.quarkus.io https://smetrics.redhat.com; 
  script-src 'self' 'unsafe-inline' 'unsafe-eval'
      
      https://assets.adobedtm.com
      js.bizographics.com
      https://www.redhat.com
      https://static.redhat.com
      https://app.requestly.io/
      jsonip.com
      https://ajax.googleapis.com
      https://use.fontawesome.com
      http://www.youtube.com
      http://www.googleadservices.com
      https://googleads.g.doubleclick.net
      https://giscus.app
      https://route-default-test-mscherer-matamo.apps.ospo-osci.z3b1.p1.openshiftapps.com/
      https://app.mailjet.com;

  style-src 'self' https://fonts.googleapis.com https://use.fontawesome.com; 
  img-src 'self' * data:; 
  media-src 'self'; 
  frame-src https://redhat.demdex.net https://www.youtube.com https://embed.restream.io https://app.mailjet.com http://xy0p2.mjt.lu https://mj.quarkus.io https://giscus.app; 
  base-uri 'none'; 
  object-src 'none'; 
  form-action 'none'; 
  font-src 'self' https://use.fontawesome.com https://fonts.gstatic.com;" />
  <script id="adobe_dtm" src="https://www.redhat.com/dtm.js" type="text/javascript"></script>
  <script src="/assets/javascript/highlight.pack.js" type="text/javascript"></script>
  <META HTTP-EQUIV='X-XSS-Protection' CONTENT="1; mode=block">
  <META HTTP-EQUIV='X-Content-Type-Options' CONTENT="nosniff">
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="Quarkus: Supersonic Subatomic Java">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@QuarkusIO"> 
  <meta name="twitter:creator" content="@QuarkusIO">
  <meta property="og:url" content="https://quarkus.io/guides/security-oidc-bearer-token-authentication" />
  <meta property="og:title" content="OpenID Connect (OIDC) Bearer token authentication" />
  <meta property="og:description" content="Quarkus: Supersonic Subatomic Java" />
  <meta property="og:image" content="https://quarkus.io/assets/images/quarkus_card.png" />
  
  <link rel="canonical" href="https://quarkus.io/guides/security-oidc-bearer-token-authentication">
  <link rel="shortcut icon" type="image/png" href="/favicon.ico" >
  <link rel="stylesheet" href="/guides/stylesheet/config.css" />
  <link rel="stylesheet" href="/assets/css/main.css?2021-07-29" />
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.5.2/css/all.css" crossorigin="anonymous">
  <link rel="alternate" type="application/rss+xml"  href="/feed.xml" title="Quarkus">
  <script src="/assets/javascript/hl.js" type="text/javascript"></script>
  
  
  
  
  <link rel="alternate" hreflang="en" href="https://quarkus.io/guides/security-oidc-bearer-token-authentication" />
  
  <link rel="alternate" hreflang="pt-br" href="https://pt.quarkus.io/guides/security-oidc-bearer-token-authentication" />
  
  <link rel="alternate" hreflang="es" href="https://es.quarkus.io/guides/security-oidc-bearer-token-authentication" />
  
  <link rel="alternate" hreflang="zh" href="https://cn.quarkus.io/guides/security-oidc-bearer-token-authentication" />
  
  <link rel="alternate" hreflang="ja" href="https://ja.quarkus.io/guides/security-oidc-bearer-token-authentication" />
  
  <link rel="alternate" hreflang="x-default" href="https://quarkus.io/" />  
  <script src="/assets/javascript/tracking.js"></script>
  
  <script src="/assets/javascript/colormode.js" type="text/javascript"></script>

</head>

<body class="guides">

  
  <div class="nav-wrapper">
  <div class="grid-wrapper">
    <div class="width-12-12">
      <input type="checkbox" id="checkbox" />
      <nav id="main-nav" class="main-nav">
        <div class="logo-wrapper">
           <a href="/"><img src="/assets/images/quarkus_logo_horizontal_rgb_600px_reverse.png" class="project-logo" title="Quarkus"></a>
        </div>
    <label class="nav-toggle" for="checkbox">
      <i class="fa fa-bars"></i>
    </label>
    <ul id="menu" class="menu">
      <li class="dropdown">
        <span href="/about/">Why<i class="fas fa-chevron-down"></i></span>
        <ul class="submenu">
          <li><a href="/about" class="">WHAT IS QUARKUS?</a></li>
          <li><a href="/container-first" class="">CONTAINER FIRST</a></li>
          <li><a href="/continuum" class="">VERSATILITY</a></li>
          <li><a href="/developer-joy" class="">DEVELOPER JOY</a></li>
          <li><a href="/kubernetes-native" class="">KUBERNETES NATIVE</a></li>
          <li><a href="/standards" class="">STANDARDS</a></li>
        </ul>
      </li>
      <li class="dropdown">
        <span href="/learn/">Learn<i class="fas fa-chevron-down"></i></span>
        <ul class="submenu">
          <li><a href="/get-started" class="">GET STARTED</a></li>
          <li><a href="/guides" class="active">DOCUMENTATION</a></li>
          <li><a href="/qtips" class="">"Q" TIP VIDEOS</a></li>          
          <li><a href="/books" class="">BOOKS</a></li>
          </ul>
      </li>
      <li class="dropdown">
        <span href="https://quarkus.io/extensions/">Extensions<i class="fas fa-chevron-down"></i></span>
        <ul class="submenu">
          <!-- Note that quarkus.io is hardcoded here, because it is the only url which supports extensions -->
          <li><a href="https://quarkus.io/extensions/" class="">BROWSE EXTENSIONS</a></li>
          <li><a href="/faq/#what-is-a-quarkus-extension" class="">USE EXTENSIONS</a></li>
          <li><a href="/guides/writing-extensions" class="">CREATE EXTENSIONS</a></li>
          <li><a href="https://hub.quarkiverse.io" class="">SHARE EXTENSIONS</a></li>
        </ul>
      </li>
      <li class="dropdown">
        <span href="/community/">Community<i class="fas fa-chevron-down"></i></span>
        <ul class="submenu">
          <li><a href="/support/" class="">SUPPORT</a></li>
          <li><a href="/blog" class="">BLOG</a></li>
          <li><a href="/discussion" class="">DISCUSSION</a></li>
          <li><a href="/working-groups" class="">WORKING GROUPS</a></li>
          <li><a href="/insights" class="">PODCAST</a></li>
          <li><a href="/events" class="">EVENTS</a></li>
          <li><a href="/newsletter" class="">NEWSLETTER</a></li>
          <li><a href="https://github.com/orgs/quarkusio/projects/13/views/1" class="">ROADMAP</a></li>
          </ul>
      </li>
      <li>
        <a href="https://code.quarkus.io" class="button-cta secondary white">START CODING</a>
      </li>
      <li class="dropdown">
        <span href="/language/"><div class="fas fa-globe langicon"></div><i class="fas fa-chevron-down"></i></span>
        <ul class="submenu">
          <li><a href="https://quarkus.io/guides/security-oidc-bearer-token-authentication" >OFFICIAL (ENGLISH)</a></li>
          <li><a href="https://pt.quarkus.io/guides/security-oidc-bearer-token-authentication">PORTUGUÊS (BR)</a></li>
          <li><a href="https://es.quarkus.io/guides/security-oidc-bearer-token-authentication">ESPAÑOL</a></li>
          <li><a href="https://cn.quarkus.io/guides/security-oidc-bearer-token-authentication">简体中文</a></li>
          <li><a href="https://ja.quarkus.io/guides/security-oidc-bearer-token-authentication">日本語</a></li>
          </ul>
      </li>
      <li>
        <span href="#" class="modeswitcher" id='theme-toggle'><i class="fas fa-sun"></i><i class="fas fa-moon"></i><i class="fas fa-cog"></i></span>
      </li>
    </ul>
      </nav>
    </div>
  </div>
</div>

  <div class="content">
    







<section class="full-width-version-bg flexfilterbar guides">
  <div class="guideflexcontainer">
    <div class="docslink">
      <a class="returnlink" href="/guides/"> Back to Guides</a>
    </div>
    <div class="flexlabel">
      <label>By Version</label>
    </div>
    <div class="guidepulldown version">
    <select id="guide-version-dropdown">
      
        
        
        <option value="main" >Main - SNAPSHOT</option>
        
        
        
        <option value="latest" selected>3.16.2 - Latest</option>
        
        
        
        <option value="3.15" >3.15</option>
        
        
        
        <option value="3.8" >3.8</option>
        
        
        
        <option value="3.2" >3.2</option>
        
        
        
        
        
        
        </select>
    </div>
  </div>
</section>

<div class="guide">
  <div class="grid-wrapper">
    <div class="grid__item width-8-12 width-12-12-m">
      
      <a class="editlink" href="https://github.com/quarkusio/quarkus/edit/main/docs/src/main/asciidoc/security-oidc-bearer-token-authentication.adoc">Edit this Page</a>
      
      <h1 class="text-caps">OpenID Connect (OIDC) Bearer token authentication </h1>
      <div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>Secure HTTP access to Jakarta REST (formerly known as JAX-RS) endpoints in your application with Bearer token authentication by using the Quarkus OpenID Connect (OIDC) extension.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="overview-of-the-bearer-token-authentication-mechanism-in-quarkus"><a class="anchor" href="#overview-of-the-bearer-token-authentication-mechanism-in-quarkus"></a>Overview of the Bearer token authentication mechanism in Quarkus</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Quarkus supports the Bearer token authentication mechanism through the Quarkus OpenID Connect (OIDC) extension.</p>
</div>
<div class="paragraph">
<p>The bearer tokens are issued by OIDC and OAuth 2.0 compliant authorization servers, such as <a href="https://www.keycloak.org">Keycloak</a>.</p>
</div>
<div class="paragraph">
<p>Bearer token authentication is the process of authorizing HTTP requests based on the existence and validity of a bearer token.
The bearer token provides information about the subject of the call, which is used to determine whether or not an HTTP resource can be accessed.</p>
</div>
<div class="paragraph">
<p>The following diagrams outline the Bearer token authentication mechanism in Quarkus:</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="/guides/images/security-bearer-token-authorization-mechanism-1.png" alt="Bearer token authentication" width="60%">
</div>
<div class="title">Figure 1. Bearer token authentication mechanism in Quarkus with single-page application</div>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>The Quarkus service retrieves verification keys from the OIDC provider.
The verification keys are used to verify the bearer access token signatures.</p>
</li>
<li>
<p>The Quarkus user accesses the single-page application (SPA).</p>
</li>
<li>
<p>The single-page application uses Authorization Code Flow to authenticate the user and retrieve tokens from the OIDC provider.</p>
</li>
<li>
<p>The single-page application uses the access token to retrieve the service data from the Quarkus service.</p>
</li>
<li>
<p>The Quarkus service verifies the bearer access token signature by using the verification keys, checks the token expiry date and other claims, allows the request to proceed if the token is valid, and returns the service response to the single-page application.</p>
</li>
<li>
<p>The single-page application returns the same data to the Quarkus user.</p>
</li>
</ol>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="/guides/images/security-bearer-token-authorization-mechanism-2.png" alt="Bearer token authentication" width="60%">
</div>
<div class="title">Figure 2. Bearer token authentication mechanism in Quarkus with Java or command line client</div>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>The Quarkus service retrieves verification keys from the OIDC provider.
The verification keys are used to verify the bearer access token signatures.</p>
</li>
<li>
<p>The client uses <code>client_credentials</code> that requires client id and secret or password grant, which requires client id, secret, username, and password to retrieve the access token from the OIDC provider.</p>
</li>
<li>
<p>The client uses the access token to retrieve the service data from the Quarkus service.</p>
</li>
<li>
<p>The Quarkus service verifies the bearer access token signature by using the verification keys, checks the token expiry date and other claims, allows the request to proceed if the token is valid, and returns the service response to the client.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>If you need to authenticate and authorize users by using OIDC authorization code flow, see the Quarkus <a href="security-oidc-code-flow-authentication">OpenID Connect authorization code flow mechanism for protecting web applications</a> guide.
Also, if you use Keycloak and bearer tokens, see the Quarkus <a href="security-keycloak-authorization">Using Keycloak to centralize authorization</a> guide.</p>
</div>
<div class="paragraph">
<p>To learn about how you can protect service applications by using OIDC Bearer token authentication, see the following tutorial:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="security-oidc-bearer-token-authentication-tutorial">Protect a service application by using OpenID Connect (OIDC) Bearer token authentication</a>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For information about how to support multiple tenants, see the Quarkus <a href="security-openid-connect-multitenancy">Using OpenID Connect Multi-Tenancy</a> guide.</p>
</div>
<div class="sect2">
<h3 id="accessing-jwt-claims"><a class="anchor" href="#accessing-jwt-claims"></a>Accessing JWT claims</h3>
<div class="paragraph">
<p>If you need to access JWT token claims, you can inject <code>JsonWebToken</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.acme.security.openid.connect;

import org.eclipse.microprofile.jwt.JsonWebToken;
import jakarta.inject.Inject;
import jakarta.annotation.security.RolesAllowed;
import jakarta.ws.rs.GET;
import jakarta.ws.rs.Path;
import jakarta.ws.rs.Produces;
import jakarta.ws.rs.core.MediaType;

@Path("/api/admin")
public class AdminResource {

    @Inject
    JsonWebToken jwt;

    @GET
    @RolesAllowed("admin")
    @Produces(MediaType.TEXT_PLAIN)
    public String admin() {
        return "Access for subject " + jwt.getSubject() + " is granted";
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Injection of <code>JsonWebToken</code> is supported in <code>@ApplicationScoped</code>, <code>@Singleton</code>, and <code>@RequestScoped</code> scopes.
However, the use of <code>@RequestScoped</code> is required if the individual claims are injected as simple types.
For more information, see the <a href="security-jwt#supported-injection-scopes">Supported injection scopes</a> section of the Quarkus "Using JWT RBAC" guide.</p>
</div>
</div>
<div class="sect2">
<h3 id="bearer-token-user-info"><a class="anchor" href="#bearer-token-user-info"></a><code>UserInfo</code></h3>
<div class="paragraph">
<p>If you must request a UserInfo JSON object from the OIDC <code>UserInfo</code> endpoint, set <code>quarkus.oidc.authentication.user-info-required=true</code>.
A request is sent to the OIDC provider <code>UserInfo</code> endpoint, and an <code>io.quarkus.oidc.UserInfo</code> (a simple <code>javax.json.JsonObject</code> wrapper) object is created.
<code>io.quarkus.oidc.UserInfo</code> can be injected or accessed as a <code>SecurityIdentity</code> <code>userinfo</code> attribute.</p>
</div>
<div class="paragraph">
<p><code>quarkus.oidc.authentication.user-info-required</code> is automatically enabled if one of these conditions is met:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>if <code>quarkus.oidc.roles.source</code> is set to <code>userinfo</code> or <code>quarkus.oidc.token.verify-access-token-with-user-info</code> is set to <code>true</code> or <code>quarkus.oidc.authentication.id-token-required</code> is set to <code>false</code>, the current OIDC tenant must support a UserInfo endpoint in these cases.</p>
</li>
<li>
<p>if <code>io.quarkus.oidc.UserInfo</code> injection point is detected but only if the current OIDC tenant supports a UserInfo endpoint.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="bearer-token-config-metadata"><a class="anchor" href="#bearer-token-config-metadata"></a>Configuration metadata</h3>
<div class="paragraph">
<p>The current tenant&#8217;s discovered <a href="https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata">OpenID Connect Configuration Metadata</a> is represented by <code>io.quarkus.oidc.OidcConfigurationMetadata</code> and can be injected or accessed as a <code>SecurityIdentity</code> <code>configuration-metadata</code> attribute.</p>
</div>
<div class="paragraph">
<p>The default tenant&#8217;s <code>OidcConfigurationMetadata</code> is injected if the endpoint is public.</p>
</div>
</div>
<div class="sect2">
<h3 id="token-claims-and-security-identity-roles"><a class="anchor" href="#token-claims-and-security-identity-roles"></a>Token claims and SecurityIdentity roles</h3>
<div class="paragraph">
<p>You can map <code>SecurityIdentity</code> roles from the verified JWT access tokens as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If the <code>quarkus.oidc.roles.role-claim-path</code> property is set, and matching array or string claims are found, then the roles are extracted from these claims.
For example, <code>customroles</code>, <code>customroles/array</code>, <code>scope</code>, <code>"http://namespace-qualified-custom-claim"/roles</code>, <code>"http://namespace-qualified-roles"</code>.</p>
</li>
<li>
<p>If a <code>groups</code> claim is available, then its value is used.</p>
</li>
<li>
<p>If a <code>realm_access/roles</code> or <code>resource_access/client_id/roles</code> (where <code>client_id</code> is the value of the <code>quarkus.oidc.client-id</code> property) claim is available, then its value is used.
This check supports the tokens issued by Keycloak.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For example, the following JWT token has a complex <code>groups</code> claim that contains a <code>roles</code> array that includes roles:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
    "iss": "https://server.example.com",
    "sub": "24400320",
    "upn": "jdoe@example.com",
    "preferred_username": "jdoe",
    "exp": 1311281970,
    "iat": 1311280970,
    "groups": {
        "roles": [
          "microprofile_jwt_user"
        ],
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You must map the <code>microprofile_jwt_user</code> role to <code>SecurityIdentity</code> roles, and you can do so with this configuration: <code>quarkus.oidc.roles.role-claim-path=groups/roles</code>.</p>
</div>
<div class="paragraph">
<p>If the token is opaque (binary), then a <code>scope</code> property from the remote token introspection response is used.</p>
</div>
<div class="paragraph">
<p>If <code>UserInfo</code> is the source of the roles, then set <code>quarkus.oidc.authentication.user-info-required=true</code> and <code>quarkus.oidc.roles.source=userinfo</code>, and if needed, set <code>quarkus.oidc.roles.role-claim-path</code>.</p>
</div>
<div class="paragraph">
<p>Additionally, a custom <code>SecurityIdentityAugmentor</code> can also be used to add the roles.
For more information, see the <a href="security-customization#security-identity-customization">Security identity customization</a> section of the Quarkus "Security tips and tricks" guide.</p>
</div>
<div class="paragraph">
<p>You can also map <code>SecurityIdentity</code> roles created from token claims to deployment-specific roles by using the <a href="security-authorize-web-endpoints-reference#map-security-identity-roles">HTTP Security policy</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="token-scopes-and-security-identity-permissions"><a class="anchor" href="#token-scopes-and-security-identity-permissions"></a>Token scopes and SecurityIdentity permissions</h3>
<div class="paragraph">
<p><code>SecurityIdentity</code> permissions are mapped in the form of <code>io.quarkus.security.StringPermission</code> from the scope parameter of the <a href="#token-claims-and-security-identity-roles">source of the roles</a> and using the same claim separator.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import java.util.List;
import jakarta.inject.Inject;
import jakarta.ws.rs.GET;
import jakarta.ws.rs.Path;

import org.eclipse.microprofile.jwt.Claims;
import org.eclipse.microprofile.jwt.JsonWebToken;

import io.quarkus.security.PermissionsAllowed;

@Path("/service")
public class ProtectedResource {

    @Inject
    JsonWebToken accessToken;

    @PermissionsAllowed("email") <i class="conum" data-value="1"></i><b>(1)</b>
    @GET
    @Path("/email")
    public Boolean isUserEmailAddressVerifiedByUser() {
        return accessToken.getClaim(Claims.email_verified.name());
    }

    @PermissionsAllowed("orders_read") <i class="conum" data-value="2"></i><b>(2)</b>
    @GET
    @Path("/order")
    public List&lt;Order&gt; listOrders() {
        return List.of(new Order("1"));
    }

    public static class Order {
        String id;
        public Order() {
        }
        public Order(String id) {
            this.id = id;
        }
        public String getId() {
            return id;
        }
        public void setId() {
            this.id = id;
        }
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Only requests with OpenID Connect scope <code>email</code> will be granted access.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The read access is limited to the client requests with the <code>orders_read</code> scope.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>For more information about the <code>io.quarkus.security.PermissionsAllowed</code> annotation, see the <a href="security-authorize-web-endpoints-reference#permission-annotation">Permission annotation</a> section of the "Authorization of web endpoints" guide.</p>
</div>
</div>
<div class="sect2">
<h3 id="bearer-token-token-verification-introspection"><a class="anchor" href="#bearer-token-token-verification-introspection"></a>Token verification and introspection</h3>
<div class="paragraph">
<p>If the token is a JWT token, then, by default, it is verified with a <code>JsonWebKey</code> (JWK) key from a local <code>JsonWebKeySet</code>, retrieved from the OIDC provider&#8217;s JWK endpoint.
The token&#8217;s key identifier (<code>kid</code>) header value is used to find the matching JWK key.
If no matching <code>JWK</code> is available locally, then <code>JsonWebKeySet</code> is refreshed by fetching the current key set from the JWK endpoint.
The <code>JsonWebKeySet</code> refresh can be repeated only after the <code>quarkus.oidc.token.forced-jwk-refresh-interval</code> expires.
The default expiry time is 10 minutes.
If no matching <code>JWK</code> is available after the refresh, the JWT token is sent to the OIDC provider&#8217;s token introspection endpoint.</p>
</div>
<div class="paragraph">
<p>If the token is opaque, which means it can be a binary token or an encrypted JWT token, then it is always sent to the OIDC provider&#8217;s token introspection endpoint.</p>
</div>
<div class="paragraph">
<p>If you work only with JWT tokens and expect a matching <code>JsonWebKey</code> to always be available, for example, after refreshing a key set, you must disable token introspection, as shown in the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">quarkus.oidc.token.allow-jwt-introspection=false
quarkus.oidc.token.allow-opaque-token-introspection=false</code></pre>
</div>
</div>
<div class="paragraph">
<p>There might be cases where JWT tokens must be verified through introspection only, which can be forced by configuring an introspection endpoint address only.
The following properties configuration shows you an example of how you can achieve this with Keycloak:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">quarkus.oidc.auth-server-url=http://localhost:8180/realms/quarkus
quarkus.oidc.discovery-enabled=false
# Token Introspection endpoint: http://localhost:8180/realms/quarkus/protocol/openid-connect/tokens/introspect
quarkus.oidc.introspection-path=/protocol/openid-connect/tokens/introspect</code></pre>
</div>
</div>
<div class="paragraph">
<p>There are advantages and disadvantages to indirectly enforcing the introspection of JWT tokens remotely.
An advantage is that you eliminate the need for two remote calls: a remote OIDC metadata discovery call followed by another remote call to fetch the verification keys that will not be used.
A disadvantage is that you need to know the introspection endpoint address and configure it manually.</p>
</div>
<div class="paragraph">
<p>The alternative approach is to allow the default option of OIDC metadata discovery but also require that only the remote JWT introspection is performed, as shown in the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">quarkus.oidc.auth-server-url=http://localhost:8180/realms/quarkus
quarkus.oidc.token.require-jwt-introspection-only=true</code></pre>
</div>
</div>
<div class="paragraph">
<p>An advantage of this approach is that the configuration is simpler and easier to understand.
A disadvantage is that a remote OIDC metadata discovery call is required to discover an introspection endpoint address, even though the verification keys will not be fetched.</p>
</div>
<div class="paragraph">
<p>The <code>io.quarkus.oidc.TokenIntrospection</code>, a simple <code>jakarta.json.JsonObject</code> wrapper object, will be created.
It can be injected or accessed as a <code>SecurityIdentity</code> <code>introspection</code> attribute, providing either the JWT or opaque token has been successfully introspected.</p>
</div>
</div>
<div class="sect2">
<h3 id="bearer-token-token-introspection-userinfo-cache"><a class="anchor" href="#bearer-token-token-introspection-userinfo-cache"></a>Token introspection and <code>UserInfo</code> cache</h3>
<div class="paragraph">
<p>All opaque access tokens must be remotely introspected.
Sometimes, JWT access tokens might also have to be introspected.
If <code>UserInfo</code> is also required, the same access token is used in a subsequent remote call to the OIDC provider.
So, if <code>UserInfo</code> is required, and the current access token is opaque, two remote calls are made for every such token; one remote call to introspect the token and another to get <code>UserInfo</code>.
If the token is JWT, only a single remote call to get <code>UserInfo</code> is needed, unless it also has to be introspected.</p>
</div>
<div class="paragraph">
<p>The cost of making up to two remote calls for every incoming bearer or code flow access token can sometimes be problematic.</p>
</div>
<div class="paragraph">
<p>If this is the case in production, consider caching the token introspection and <code>UserInfo</code> data for a short period, for example, 3 or 5 minutes.</p>
</div>
<div class="paragraph">
<p><code>quarkus-oidc</code> provides <code>quarkus.oidc.TokenIntrospectionCache</code> and <code>quarkus.oidc.UserInfoCache</code> interfaces, usable for <code>@ApplicationScoped</code> cache implementation.
Use <code>@ApplicationScoped</code> cache implementation to store and retrieve <code>quarkus.oidc.TokenIntrospection</code> and/or <code>quarkus.oidc.UserInfo</code> objects, as outlined in the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ApplicationScoped
@Alternative
@Priority(1)
public class CustomIntrospectionUserInfoCache implements TokenIntrospectionCache, UserInfoCache {
...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Each OIDC tenant can either permit or deny the storing of its <code>quarkus.oidc.TokenIntrospection</code> data, <code>quarkus.oidc.UserInfo</code> data, or both with boolean <code>quarkus.oidc."tenant".allow-token-introspection-cache</code> and <code>quarkus.oidc."tenant".allow-user-info-cache</code> properties.</p>
</div>
<div class="paragraph">
<p>Additionally, <code>quarkus-oidc</code> provides a simple default memory-based token cache, which implements both <code>quarkus.oidc.TokenIntrospectionCache</code> and <code>quarkus.oidc.UserInfoCache</code> interfaces.</p>
</div>
<div class="paragraph">
<p>You can configure and activate the default OIDC token cache as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties"># 'max-size' is 0 by default, so the cache can be activated by setting 'max-size' to a positive value:
quarkus.oidc.token-cache.max-size=1000
# 'time-to-live' specifies how long a cache entry can be valid for and will be used by a cleanup timer:
quarkus.oidc.token-cache.time-to-live=3M
# 'clean-up-timer-interval' is not set by default, so the cleanup timer can be activated by setting 'clean-up-timer-interval':
quarkus.oidc.token-cache.clean-up-timer-interval=1M</code></pre>
</div>
</div>
<div class="paragraph">
<p>The default cache uses a token as a key, and each entry can have <code>TokenIntrospection</code>, <code>UserInfo</code>, or both.
It will only keep up to a <code>max-size</code> number of entries.
If the cache is already full when a new entry is to be added, an attempt is made to find a space by removing a single expired entry.
Additionally, the cleanup timer, if activated, periodically checks for expired entries and removes them.</p>
</div>
<div class="paragraph">
<p>You can experiment with the default cache implementation or register a custom one.</p>
</div>
</div>
<div class="sect2">
<h3 id="bearer-token-jwt-claim-verification"><a class="anchor" href="#bearer-token-jwt-claim-verification"></a>JSON Web Token claim verification</h3>
<div class="paragraph">
<p>After the bearer JWT token&#8217;s signature has been verified and its <code>expires at</code> (<code>exp</code>) claim has been checked, the <code>iss</code> (<code>issuer</code>) claim value is verified next.</p>
</div>
<div class="paragraph">
<p>By default, the <code>iss</code> claim value is compared to the <code>issuer</code> property, which might have been discovered in the well-known provider configuration.
However, if the <code>quarkus.oidc.token.issuer</code> property is set, then the <code>iss</code> claim value is compared to it instead.</p>
</div>
<div class="paragraph">
<p>In some cases, this <code>iss</code> claim verification might not work.
For example, if the discovered <code>issuer</code> property contains an internal HTTP/IP address while the token <code>iss</code> claim value contains an external HTTP/IP address.
Or when a discovered <code>issuer</code> property contains the template tenant variable, but the token <code>iss</code> claim value has the complete tenant-specific issuer value.</p>
</div>
<div class="paragraph">
<p>In such cases, consider skipping the issuer verification by setting <code>quarkus.oidc.token.issuer=any</code>.
Only skip the issuer verification if no other options are available:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If you are using Keycloak and observe the issuer verification errors caused by the different host addresses, configure Keycloak with a <code>KEYCLOAK_FRONTEND_URL</code> property to ensure the same host address is used.</p>
</li>
<li>
<p>If the <code>iss</code> property is tenant-specific in a multitenant deployment, use the <code>SecurityIdentity</code> <code>tenant-id</code> attribute to check that the issuer is correct in the endpoint or the custom Jakarta filter.
For example:</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import jakarta.inject.Inject;
import jakarta.ws.rs.container.ContainerRequestContext;
import jakarta.ws.rs.container.ContainerRequestFilter;
import jakarta.ws.rs.core.Response;
import jakarta.ws.rs.ext.Provider;

import org.eclipse.microprofile.jwt.JsonWebToken;
import io.quarkus.oidc.OidcConfigurationMetadata;
import io.quarkus.security.identity.SecurityIdentity;

@Provider
public class IssuerValidator implements ContainerRequestFilter {
    @Inject
    OidcConfigurationMetadata configMetadata;

    @Inject JsonWebToken jwt;
    @Inject SecurityIdentity identity;

    public void filter(ContainerRequestContext requestContext) {
        String issuer = configMetadata.getIssuer().replace("{tenant-id}", identity.getAttribute("tenant-id"));
        if (!issuer.equals(jwt.getIssuer())) {
            requestContext.abortWith(Response.status(401).build());
        }
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Consider using the <code>quarkus.oidc.token.audience</code> property to verify the token <code>aud</code> (<code>audience</code>) claim value.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="jose4j-validator"><a class="anchor" href="#jose4j-validator"></a>Jose4j Validator</h3>
<div class="paragraph">
<p>You can register a custom <a href="https://www.javadoc.io/doc/org.bitbucket.b_c/jose4j/latest/org/jose4j/jwt/consumer/class-use/Validator.html">Jose4j Validator</a> to customize the JWT claim verification process, before <code>org.eclipse.microprofile.jwt.JsonWebToken</code> is initialized.
For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.acme.security.openid.connect;

import static org.eclipse.microprofile.jwt.Claims.iss;

import io.quarkus.arc.Unremovable;
import jakarta.enterprise.context.ApplicationScoped;

import org.jose4j.jwt.MalformedClaimException;
import org.jose4j.jwt.consumer.JwtContext;
import org.jose4j.jwt.consumer.Validator;

@Unremovable
@ApplicationScoped
public class IssuerValidator implements Validator { <i class="conum" data-value="1"></i><b>(1)</b>

    @Override
    public String validate(JwtContext jwtContext) throws MalformedClaimException {
        if (jwtContext.getJwtClaims().hasClaim(iss.name())
                &amp;&amp; "my-issuer".equals(jwtContext.getJwtClaims().getClaimValueAsString(iss.name()))) {
            return "wrong issuer"; <i class="conum" data-value="2"></i><b>(2)</b>
        }
        return null; <i class="conum" data-value="3"></i><b>(3)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Register Jose4j Validator to verify JWT tokens for all OIDC tenants.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Return the claim verification error description.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Return <code>null</code> to confirm that this Validator has successfully verified the token.</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Use a <code>@quarkus.oidc.TenantFeature</code> annotation to bind a custom Validator to a specific OIDC tenant only.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="single-page-applications"><a class="anchor" href="#single-page-applications"></a>Single-page applications</h3>
<div class="paragraph">
<p>A single-page application (SPA) typically uses <code>XMLHttpRequest</code>(XHR) and the JavaScript utility code provided by the OIDC provider to acquire a bearer token to access Quarkus <code>service</code> applications.</p>
</div>
<div class="paragraph">
<p>For example, if you work with Keycloak, you can use <code>keycloak.js</code> to authenticate users and refresh the expired tokens from the SPA:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;keycloak-spa&lt;/title&gt;
    &lt;script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"&gt;&lt;/script&gt;
    &lt;script src="http://localhost:8180/js/keycloak.js"&gt;&lt;/script&gt;
    &lt;script&gt;
        var keycloak = new Keycloak();
        keycloak.init({onLoad: 'login-required'}).success(function () {
            console.log('User is now authenticated.');
        }).error(function () {
            window.location.reload();
        });
        function makeAjaxRequest() {
            axios.get("/api/hello", {
                headers: {
                    'Authorization': 'Bearer ' + keycloak.token
                }
            })
            .then( function (response) {
                console.log("Response: ", response.status);
            }).catch(function (error) {
                console.log('refreshing');
                keycloak.updateToken(5).then(function () {
                    console.log('Token refreshed');
                }).catch(function () {
                    console.log('Failed to refresh token');
                    window.location.reload();
                });
            });
    }
    &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;button onclick="makeAjaxRequest()"&gt;Request&lt;/button&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="cross-origin-resource-sharing"><a class="anchor" href="#cross-origin-resource-sharing"></a>Cross-origin resource sharing</h3>
<div class="paragraph">
<p>If you plan to use your OIDC <code>service</code> application from a single-page application running on a different domain, you must configure cross-origin resource sharing (CORS).
For more information, see the <a href="security-cors#cors-filter">CORS filter</a> section of the "Cross-origin resource sharing" guide.</p>
</div>
</div>
<div class="sect2">
<h3 id="provider-endpoint-configuration"><a class="anchor" href="#provider-endpoint-configuration"></a>Provider endpoint configuration</h3>
<div class="paragraph">
<p>An OIDC <code>service</code> application needs to know the OIDC provider&#8217;s token, <code>JsonWebKey</code> (JWK) set, and possibly <code>UserInfo</code> and introspection endpoint addresses.</p>
</div>
<div class="paragraph">
<p>By default, they are discovered by adding a <code>/.well-known/openid-configuration</code> path to the configured <code>quarkus.oidc.auth-server-url</code>.</p>
</div>
<div class="paragraph">
<p>Alternatively, if the discovery endpoint is not available, or if you want to save on the discovery endpoint round-trip, you can disable the discovery and configure them with relative path values.
For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">quarkus.oidc.auth-server-url=http://localhost:8180/realms/quarkus
quarkus.oidc.discovery-enabled=false
# Token endpoint: http://localhost:8180/realms/quarkus/protocol/openid-connect/token
quarkus.oidc.token-path=/protocol/openid-connect/token
# JWK set endpoint: http://localhost:8180/realms/quarkus/protocol/openid-connect/certs
quarkus.oidc.jwks-path=/protocol/openid-connect/certs
# UserInfo endpoint: http://localhost:8180/realms/quarkus/protocol/openid-connect/userinfo
quarkus.oidc.user-info-path=/protocol/openid-connect/userinfo
# Token Introspection endpoint: http://localhost:8180/realms/quarkus/protocol/openid-connect/tokens/introspect
quarkus.oidc.introspection-path=/protocol/openid-connect/tokens/introspect</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="token-propagation"><a class="anchor" href="#token-propagation"></a>Token propagation</h3>
<div class="paragraph">
<p>For information about bearer access token propagation to the downstream services, see the <a href="security-openid-connect-client-reference#token-propagation-rest">Token propagation</a> section of the Quarkus "OpenID Connect (OIDC) and OAuth2 client and filters reference" guide.</p>
</div>
</div>
<div class="sect2">
<h3 id="jwt-token-certificate-chain"><a class="anchor" href="#jwt-token-certificate-chain"></a>JWT token certificate chain</h3>
<div class="paragraph">
<p>In some cases, JWT bearer tokens have an <code>x5c</code> header which represents an X509 certificate chain whose leaf certificate contains a public key that must be used to verify this token&#8217;s signature.
Before this public key can be accepted to verify the signature, the certificate chain must be validated first.
The certificate chain validation involves several steps:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Confirm that every certificate but the root one is signed by the parent certificate.</p>
</li>
<li>
<p>Confirm the chain&#8217;s root certificate is also imported in the truststore.</p>
</li>
<li>
<p>Validate the chain&#8217;s leaf certificate. If a common name of the leaf certificate is configured then a common name of the chain&#8217;s leaf certificate must match it. Otherwise the chain&#8217;s leaf certificate must also be avaiable in the truststore, unless one or more custom <code>TokenCertificateValidator</code> implementations are registered.</p>
</li>
<li>
<p><code>quarkus.oidc.TokenCertificateValidator</code> can be used to add a custom certificate chain validation step. It can be used by all tenants expecting tokens with the certificate chain or bound to specific OIDC tenants with the <code>@quarkus.oidc.TenantFeature</code> annotation.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>For example, here is how you can configure Quarkus OIDC to verify the token&#8217;s certificate chain, without using <code>quarkus.oidc.TokenCertificateValidator</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">quarkus.oidc.certificate-chain.trust-store-file=truststore-rootcert.p12 <i class="conum" data-value="1"></i><b>(1)</b>
quarkus.oidc.certificate-chain.trust-store-password=storepassword
quarkus.oidc.certificate-chain.leaf-certificate-name=www.quarkusio.com <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The truststore must contain the certificate chain&#8217;s root certificate.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The certificate chain&#8217;s leaf certificate must have a common name equal to <code>www.quarkusio.com</code>. If this property is not configured then the truststore must contain the certificate chain&#8217;s leaf certificate unless one or more custom <code>TokenCertificateValidator</code> implementations are registered.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>You can add a custom certificate chain validation step by registering a custom <code>quarkus.oidc.TokenCertificateValidator</code>, for example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package io.quarkus.it.keycloak;

import java.security.cert.CertificateException;
import java.security.cert.X509Certificate;
import java.util.List;

import jakarta.enterprise.context.ApplicationScoped;

import io.quarkus.arc.Unremovable;
import io.quarkus.oidc.OidcTenantConfig;
import io.quarkus.oidc.TokenCertificateValidator;
import io.quarkus.oidc.runtime.TrustStoreUtils;
import io.vertx.core.json.JsonObject;

@ApplicationScoped
@Unremovable
public class BearerGlobalTokenChainValidator implements TokenCertificateValidator {

    @Override
    public void validate(OidcTenantConfig oidcConfig, List&lt;X509Certificate&gt; chain, String tokenClaims) throws CertificateException {
        String rootCertificateThumbprint = TrustStoreUtils.calculateThumprint(chain.get(chain.size() - 1));
        JsonObject claims = new JsonObject(tokenClaims);
        if (!rootCertificateThumbprint.equals(claims.getString("root-certificate-thumbprint"))) { <i class="conum" data-value="1"></i><b>(1)</b>
            throw new CertificateException("Invalid root certificate");
        }
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Confirm that the certificate chain&#8217;s root certificate is bound to the custom JWT token&#8217;s claim.</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="oidc-provider-client-authentication"><a class="anchor" href="#oidc-provider-client-authentication"></a>OIDC provider client authentication</h3>
<div class="paragraph">
<p><code>quarkus.oidc.runtime.OidcProviderClient</code> is used when a remote request to an OIDC provider is required.
If introspection of the Bearer token is necessary, then <code>OidcProviderClient</code> must authenticate to the OIDC provider.
For more information about supported authentication options, see the  <a href="security-oidc-code-flow-authentication#oidc-provider-client-authentication">OIDC provider client authentication</a> section in the Quarkus "OpenID Connect authorization code flow mechanism for protecting web applications" guide.</p>
</div>
</div>
<div class="sect2">
<h3 id="bearer-token-integration-testing"><a class="anchor" href="#bearer-token-integration-testing"></a>Testing</h3>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>If you have to test Quarkus OIDC service endpoints that require <a href="security-keycloak-authorization">Keycloak authorization</a>, follow the <a href="security-keycloak-authorization#testing">Test Keycloak authorization</a> section.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>You can begin testing by adding the following dependencies to your test project:</p>
</div>
<div class="listingblock primary asciidoc-tabs-target-sync-cli asciidoc-tabs-target-sync-maven">
<div class="title">pom.xml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;io.rest-assured&lt;/groupId&gt;
    &lt;artifactId&gt;rest-assured&lt;/artifactId&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
    &lt;artifactId&gt;quarkus-junit5&lt;/artifactId&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary asciidoc-tabs-target-sync-gradle">
<div class="title">build.gradle</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-gradle hljs" data-lang="gradle">testImplementation("io.rest-assured:rest-assured")
testImplementation("io.quarkus:quarkus-junit5")</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="bearer-token-integration-testing-wiremock"><a class="anchor" href="#bearer-token-integration-testing-wiremock"></a>WireMock</h4>
<div class="paragraph">
<p>Add the following dependencies to your test project:</p>
</div>
<div class="listingblock primary asciidoc-tabs-target-sync-cli asciidoc-tabs-target-sync-maven">
<div class="title">pom.xml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
    &lt;artifactId&gt;quarkus-test-oidc-server&lt;/artifactId&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary asciidoc-tabs-target-sync-gradle">
<div class="title">build.gradle</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-gradle hljs" data-lang="gradle">testImplementation("io.quarkus:quarkus-test-oidc-server")</code></pre>
</div>
</div>
<div class="paragraph">
<p>Prepare the REST test endpoint and set <code>application.properties</code>.
For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties"># keycloak.url is set by OidcWiremockTestResource
quarkus.oidc.auth-server-url=${keycloak.url:replaced-by-test-resource}/realms/quarkus/
quarkus.oidc.client-id=quarkus-service-app
quarkus.oidc.application-type=service</code></pre>
</div>
</div>
<div class="paragraph">
<p>Finally, write the test code.
For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import static org.hamcrest.Matchers.equalTo;

import java.util.Set;

import org.junit.jupiter.api.Test;

import io.quarkus.test.common.QuarkusTestResource;
import io.quarkus.test.junit.QuarkusTest;
import io.quarkus.test.oidc.server.OidcWiremockTestResource;
import io.restassured.RestAssured;
import io.smallrye.jwt.build.Jwt;

@QuarkusTest
@QuarkusTestResource(OidcWiremockTestResource.class)
public class BearerTokenAuthorizationTest {

    @Test
    public void testBearerToken() {
        RestAssured.given().auth().oauth2(getAccessToken("alice", Set.of("user")))
            .when().get("/api/users/me")
            .then()
            .statusCode(200)
            // The test endpoint returns the name extracted from the injected `SecurityIdentity` principal.
            .body("userName", equalTo("alice"));
    }

    private String getAccessToken(String userName, Set&lt;String&gt; groups) {
        return Jwt.preferredUserName(userName)
                .groups(groups)
                .issuer("https://server.example.com")
                .audience("https://service.example.com")
                .sign();
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>quarkus-test-oidc-server</code> extension includes a signing RSA private key file in a <code>JSON Web Key</code> (<code>JWK</code>) format and points to it with a <code>smallrye.jwt.sign.key.location</code> configuration property.
It allows you to sign the token by using a no-argument <code>sign()</code> operation.</p>
</div>
<div class="paragraph">
<p>Testing your <code>quarkus-oidc</code> <code>service</code> application with <code>OidcWiremockTestResource</code> provides the best coverage because even the communication channel is tested against the WireMock HTTP stubs.
If you need to run a test with WireMock stubs that are not yet supported by <code>OidcWiremockTestResource</code>, you can inject a <code>WireMockServer</code> instance into the test class, as shown in the following example:</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>OidcWiremockTestResource</code> does not work with <code>@QuarkusIntegrationTest</code> against Docker containers because the WireMock server runs in the JVM that runs the test, which is inaccessible from the Docker container that runs the Quarkus application.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package io.quarkus.it.keycloak;

import static com.github.tomakehurst.wiremock.client.WireMock.matching;
import static org.hamcrest.Matchers.equalTo;

import org.junit.jupiter.api.Test;

import com.github.tomakehurst.wiremock.WireMockServer;
import com.github.tomakehurst.wiremock.client.WireMock;

import io.quarkus.test.junit.QuarkusTest;
import io.quarkus.test.oidc.server.OidcWireMock;
import io.restassured.RestAssured;

@QuarkusTest
public class CustomOidcWireMockStubTest {

    @OidcWireMock
    WireMockServer wireMockServer;

    @Test
    public void testInvalidBearerToken() {
        wireMockServer.stubFor(WireMock.post("/auth/realms/quarkus/protocol/openid-connect/token/introspect")
                .withRequestBody(matching(".*token=invalid_token.*"))
                .willReturn(WireMock.aResponse().withStatus(400)));

        RestAssured.given().auth().oauth2("invalid_token").when()
                .get("/api/users/me/bearer")
                .then()
                .statusCode(401)
                .header("WWW-Authenticate", equalTo("Bearer"));
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="integration-testing-oidc-test-client"><a class="anchor" href="#integration-testing-oidc-test-client"></a><code>OidcTestClient</code></h3>
<div class="paragraph">
<p>If you use SaaS OIDC providers, such as <code>Auth0</code>, and want to run tests against the test (development) domain or to run tests against a remote Keycloak test realm, if you already have <code>quarkus.oidc.auth-server-url</code> configured, you can use <code>OidcTestClient</code>.</p>
</div>
<div class="paragraph">
<p>For example, you have the following configuration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">%test.quarkus.oidc.auth-server-url=https://dev-123456.eu.auth0.com/
%test.quarkus.oidc.client-id=test-auth0-client
%test.quarkus.oidc.credentials.secret=secret</code></pre>
</div>
</div>
<div class="paragraph">
<p>To start, add the same dependency, <code>quarkus-test-oidc-server</code>, as described in the <a href="#bearer-token-integration-testing-wiremock">WireMock</a> section.</p>
</div>
<div class="paragraph">
<p>Next, write the test code as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.acme;

import org.junit.jupiter.api.AfterAll;
import static io.restassured.RestAssured.given;
import static org.hamcrest.CoreMatchers.is;

import java.util.Map;

import org.junit.jupiter.api.Test;

import io.quarkus.test.junit.QuarkusTest;
import io.quarkus.test.oidc.client.OidcTestClient;

@QuarkusTest
public class GreetingResourceTest {

    static OidcTestClient oidcTestClient = new OidcTestClient();

    @AfterAll
    public static void close() {
        oidcTestClient.close();
    }

    @Test
    public void testHelloEndpoint() {
        given()
          .auth().oauth2(getAccessToken("alice", "alice"))
          .when().get("/hello")
          .then()
             .statusCode(200)
             .body(is("Hello, Alice"));
    }

    private String getAccessToken(String name, String secret) {
        return oidcTestClient.getAccessToken(name, secret,
            Map.of("audience", "https://dev-123456.eu.auth0.com/api/v2/",
	           "scope", "profile"));
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This test code acquires a token by using a <code>password</code> grant from the test <code>Auth0</code> domain, which has registered an application with the client id <code>test-auth0-client</code>, and created the user <code>alice</code> with password <code>alice</code>.
For a test like this to work, the test <code>Auth0</code> application must have the <code>password</code> grant enabled.
This example code also shows how to pass additional parameters.
For <code>Auth0</code>, these are the <code>audience</code> and <code>scope</code> parameters.</p>
</div>
<div class="sect3">
<h4 id="bearer-token-integration-testing-keycloak-devservices"><a class="anchor" href="#bearer-token-integration-testing-keycloak-devservices"></a>Dev Services for Keycloak</h4>
<div class="paragraph">
<p>The preferred approach for integration testing against Keycloak is <a href="security-openid-connect-dev-services">Dev Services for Keycloak</a>.
<code>Dev Services for Keycloak</code> will start and initialize a test container.
Then, it will create a <code>quarkus</code> realm and a <code>quarkus-app</code> client (<code>secret</code> secret) and add <code>alice</code> (<code>admin</code> and <code>user</code> roles) and <code>bob</code> (<code>user</code> role) users, where all of these properties can be customized.</p>
</div>
<div class="paragraph">
<p>First, add the following dependency, which provides a utility class <code>io.quarkus.test.keycloak.client.KeycloakTestClient</code> that you can use in tests for acquiring the access tokens:</p>
</div>
<div class="listingblock primary asciidoc-tabs-target-sync-cli asciidoc-tabs-target-sync-maven">
<div class="title">pom.xml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
    &lt;artifactId&gt;quarkus-test-keycloak-server&lt;/artifactId&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary asciidoc-tabs-target-sync-gradle">
<div class="title">build.gradle</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-gradle hljs" data-lang="gradle">testImplementation("io.quarkus:quarkus-test-keycloak-server")</code></pre>
</div>
</div>
<div class="paragraph">
<p>Next, prepare your <code>application.properties</code> configuration file.
You can start with an empty <code>application.properties</code> file because <code>Dev Services for Keycloak</code> registers <code>quarkus.oidc.auth-server-url</code> and points it to the running test container, <code>quarkus.oidc.client-id=quarkus-app</code>, and <code>quarkus.oidc.credentials.secret=secret</code>.</p>
</div>
<div class="paragraph">
<p>However, if you have already configured the required <code>quarkus-oidc</code> properties, then you only need to associate <code>quarkus.oidc.auth-server-url</code> with the <code>prod</code> profile for `Dev Services for Keycloak`to start a container, as shown in the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">%prod.quarkus.oidc.auth-server-url=http://localhost:8180/realms/quarkus</code></pre>
</div>
</div>
<div class="paragraph">
<p>If a custom realm file has to be imported into Keycloak before running the tests, configure <code>Dev Services for Keycloak</code> as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">%prod.quarkus.oidc.auth-server-url=http://localhost:8180/realms/quarkus
quarkus.keycloak.devservices.realm-path=quarkus-realm.json</code></pre>
</div>
</div>
<div class="paragraph">
<p>Finally, write your test, which will be executed in JVM mode, as shown in the following examples:</p>
</div>
<div class="listingblock">
<div class="title">Example of a test executed in JVM mode:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.acme.security.openid.connect;

import io.quarkus.test.junit.QuarkusTest;
import io.quarkus.test.keycloak.client.KeycloakTestClient;
import io.restassured.RestAssured;
import org.junit.jupiter.api.Test;

@QuarkusTest
public class BearerTokenAuthenticationTest {

    KeycloakTestClient keycloakClient = new KeycloakTestClient();

    @Test
    public void testAdminAccess() {
        RestAssured.given().auth().oauth2(getAccessToken("alice"))
                .when().get("/api/admin")
                .then()
                .statusCode(200);
        RestAssured.given().auth().oauth2(getAccessToken("bob"))
                .when().get("/api/admin")
                .then()
                .statusCode(403);
    }

    protected String getAccessToken(String userName) {
        return keycloakClient.getAccessToken(userName);
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Example of a test executed in native mode:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.acme.security.openid.connect;

import io.quarkus.test.junit.QuarkusIntegrationTest;

@QuarkusIntegrationTest
public class NativeBearerTokenAuthenticationIT extends BearerTokenAuthenticationTest {
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>For more information about initializing and configuring Dev Services for Keycloak, see the <a href="security-openid-connect-dev-services">Dev Services for Keycloak</a> guide.</p>
</div>
</div>
<div class="sect3">
<h4 id="bearer-token-integration-testing-keycloak"><a class="anchor" href="#bearer-token-integration-testing-keycloak"></a><code>KeycloakTestResourceLifecycleManager</code></h4>
<div class="paragraph">
<p>You can also use <code>KeycloakTestResourceLifecycleManager</code> for integration testing with Keycloak.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Use <a href="#bearer-token-integration-testing-keycloak-devservices">Dev Services for Keycloak</a> instead of <code>KeycloakTestResourceLifecycleManager</code> for integration testing with Keycloak, unless you have specific requirements for using <code>KeycloakTestResourceLifecycleManager</code>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>First, add the following dependency:</p>
</div>
<div class="listingblock primary asciidoc-tabs-target-sync-cli asciidoc-tabs-target-sync-maven">
<div class="title">pom.xml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
    &lt;artifactId&gt;quarkus-test-keycloak-server&lt;/artifactId&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary asciidoc-tabs-target-sync-gradle">
<div class="title">build.gradle</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-gradle hljs" data-lang="gradle">testImplementation("io.quarkus:quarkus-test-keycloak-server")</code></pre>
</div>
</div>
<div class="paragraph">
<p>It provides <code>io.quarkus.test.keycloak.server.KeycloakTestResourceLifecycleManager</code>, which is an implementation of <code>io.quarkus.test.common.QuarkusTestResourceLifecycleManager</code> that starts a Keycloak container.</p>
</div>
<div class="paragraph">
<p>Configure the Maven Surefire plugin as follows, or similarly with <code>maven.failsafe.plugin</code> for native image testing:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;plugin&gt;
    &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;
    &lt;configuration&gt;
        &lt;systemPropertyVariables&gt;
            &lt;!-- Or, alternatively, configure 'keycloak.version' --&gt;
            &lt;keycloak.docker.image&gt;${keycloak.docker.image}&lt;/keycloak.docker.image&gt;
            &lt;!--
              Disable HTTPS if required:
              &lt;keycloak.use.https&gt;false&lt;/keycloak.use.https&gt;
            --&gt;
        &lt;/systemPropertyVariables&gt;
    &lt;/configuration&gt;
&lt;/plugin&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Prepare the REST test endpoint and set <code>application.properties</code> as outlined in the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties"># keycloak.url is set by KeycloakTestResourceLifecycleManager
quarkus.oidc.auth-server-url=${keycloak.url:replaced-by-test-resource}/realms/quarkus/
quarkus.oidc.client-id=quarkus-service-app
quarkus.oidc.credentials=secret
quarkus.oidc.application-type=service</code></pre>
</div>
</div>
<div class="paragraph">
<p>Finally, write the test code.
For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import static io.quarkus.test.keycloak.server.KeycloakTestResourceLifecycleManager.getAccessToken;
import static org.hamcrest.Matchers.equalTo;

import org.junit.jupiter.api.Test;

import io.quarkus.test.common.QuarkusTestResource;
import io.quarkus.test.junit.QuarkusTest;
import io.quarkus.test.keycloak.server.KeycloakTestResourceLifecycleManager;
import io.restassured.RestAssured;

@QuarkusTest
@QuarkusTestResource(KeycloakTestResourceLifecycleManager.class)
public class BearerTokenAuthorizationTest {

    @Test
    public void testBearerToken() {
        RestAssured.given().auth().oauth2(getAccessToken("alice"))
            .when().get("/api/users/preferredUserName")
            .then()
            .statusCode(200)
            // The test endpoint returns the name extracted from the injected SecurityIdentity Principal
            .body("userName", equalTo("alice"));
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<div class="title">Summary</div>
<p>In the provided example, <code>KeycloakTestResourceLifecycleManager</code> registers two users: <code>alice</code> and <code>admin</code>.
By default:
* The user <code>alice</code> has the <code>user</code> role, which you can customize by using a <code>keycloak.token.user-roles</code> system property.
* The user <code>admin</code> has both the <code>user</code> and <code>admin</code> roles, which you can customize by using the <code>keycloak.token.admin-roles</code> system property.</p>
</div>
<div class="paragraph">
<p>By default, <code>KeycloakTestResourceLifecycleManager</code> uses HTTPS to initialize a Keycloak instance, and this can be disabled by using <code>keycloak.use.https=false</code>.
The default realm name is <code>quarkus</code>, and the client id is <code>quarkus-service-app</code>.
If you want to customize these values, set the <code>keycloak.realm</code> and <code>keycloak.service.client</code> system properties.</p>
</div>
</div>
<div class="sect3">
<h4 id="integration-testing-public-key"><a class="anchor" href="#integration-testing-public-key"></a>Local public key</h4>
<div class="paragraph">
<p>You can use a local inlined public key for testing your <code>quarkus-oidc</code> <code>service</code> applications, as shown in the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">quarkus.oidc.client-id=test
quarkus.oidc.public-key=MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAlivFI8qB4D0y2jy0CfEqFyy46R0o7S8TKpsx5xbHKoU1VWg6QkQm+ntyIv1p4kE1sPEQO73+HY8+Bzs75XwRTYL1BmR1w8J5hmjVWjc6R2BTBGAYRPFRhor3kpM6ni2SPmNNhurEAHw7TaqszP5eUF/F9+KEBWkwVta+PZ37bwqSE4sCb1soZFrVz/UT/LF4tYpuVYt3YbqToZ3pZOZ9AX2o1GCG3xwOjkc4x0W7ezbQZdC9iftPxVHR8irOijJRRjcPDtA6vPKpzLl6CyYnsIYPd99ltwxTHjr3npfv/3Lw50bAkbT4HeLFxTx4flEoZLKO/g0bAoV2uqBhkA9xnQIDAQAB

smallrye.jwt.sign.key.location=/privateKey.pem</code></pre>
</div>
</div>
<div class="paragraph">
<p>To generate JWT tokens, copy <code>privateKey.pem</code> from the <code>integration-tests/oidc-tenancy</code> in the <code>main</code> Quarkus repository and use a test code similar to the one in the preceding <a href="#bearer-token-integration-testing-wiremock">WireMock</a> section.
You can use your own test keys, if preferred.</p>
</div>
<div class="paragraph">
<p>This approach provides limited coverage compared to the WireMock approach.
For example, the remote communication code is not covered.</p>
</div>
</div>
<div class="sect3">
<h4 id="bearer-token-integration-testing-security-annotation"><a class="anchor" href="#bearer-token-integration-testing-security-annotation"></a>TestSecurity annotation</h4>
<div class="paragraph">
<p>You can use <code>@TestSecurity</code> and <code>@OidcSecurity</code> annotations to test the <code>service</code> application endpoint code, which depends on either one, or all three, of the following injections:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>JsonWebToken</code></p>
</li>
<li>
<p><code>UserInfo</code></p>
</li>
<li>
<p><code>OidcConfigurationMetadata</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>First, add the following dependency:</p>
</div>
<div class="listingblock primary asciidoc-tabs-target-sync-cli asciidoc-tabs-target-sync-maven">
<div class="title">pom.xml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
    &lt;artifactId&gt;quarkus-test-security-oidc&lt;/artifactId&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary asciidoc-tabs-target-sync-gradle">
<div class="title">build.gradle</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-gradle hljs" data-lang="gradle">testImplementation("io.quarkus:quarkus-test-security-oidc")</code></pre>
</div>
</div>
<div class="paragraph">
<p>Write a test code as outlined in the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import static org.hamcrest.Matchers.is;
import org.junit.jupiter.api.Test;
import io.quarkus.test.common.http.TestHTTPEndpoint;
import io.quarkus.test.junit.QuarkusTest;
import io.quarkus.test.security.TestSecurity;
import io.quarkus.test.security.oidc.Claim;
import io.quarkus.test.security.oidc.ConfigMetadata;
import io.quarkus.test.security.oidc.OidcSecurity;
import io.quarkus.test.security.oidc.UserInfo;
import io.restassured.RestAssured;

@QuarkusTest
@TestHTTPEndpoint(ProtectedResource.class)
public class TestSecurityAuthTest {

    @Test
    @TestSecurity(user = "userOidc", roles = "viewer")
    public void testOidc() {
        RestAssured.when().get("test-security-oidc").then()
                .body(is("userOidc:viewer"));
    }

    @Test
    @TestSecurity(user = "userOidc", roles = "viewer")
    @OidcSecurity(claims = {
            @Claim(key = "email", value = "user@gmail.com")
    }, userinfo = {
            @UserInfo(key = "sub", value = "subject")
    }, config = {
            @ConfigMetadata(key = "issuer", value = "issuer")
    })
    public void testOidcWithClaimsUserInfoAndMetadata() {
        RestAssured.when().get("test-security-oidc-claims-userinfo-metadata").then()
                .body(is("userOidc:viewer:user@gmail.com:subject:issuer"));
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>ProtectedResource</code> class, which is used in this code example, might look like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import jakarta.inject.Inject;
import jakarta.ws.rs.GET;
import jakarta.ws.rs.Path;

import io.quarkus.oidc.OidcConfigurationMetadata;
import io.quarkus.oidc.UserInfo;
import io.quarkus.security.Authenticated;

import org.eclipse.microprofile.jwt.JsonWebToken;

@Path("/service")
@Authenticated
public class ProtectedResource {

    @Inject
    JsonWebToken accessToken;
    @Inject
    UserInfo userInfo;
    @Inject
    OidcConfigurationMetadata configMetadata;

    @GET
    @Path("test-security-oidc")
    public String testSecurityOidc() {
        return accessToken.getName() + ":" + accessToken.getGroups().iterator().next();
    }

    @GET
    @Path("test-security-oidc-claims-userinfo-metadata")
    public String testSecurityOidcWithClaimsUserInfoMetadata() {
        return accessToken.getName() + ":" + accessToken.getGroups().iterator().next()
                + ":" + accessToken.getClaim("email")
                + ":" + userInfo.getString("sub")
                + ":" + configMetadata.get("issuer");
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You must always use the <code>@TestSecurity</code> annotation.
Its <code>user</code> property is returned as <code>JsonWebToken.getName()</code> and its <code>roles</code> property is returned as <code>JsonWebToken.getGroups()</code>.
The <code>@OidcSecurity</code> annotation is optional and you can use it to set the additional token claims and the <code>UserInfo</code> and <code>OidcConfigurationMetadata</code> properties.
Additionally, if the <code>quarkus.oidc.token.issuer</code> property is configured, it is used as an <code>OidcConfigurationMetadata</code> <code>issuer</code> property value.</p>
</div>
<div class="paragraph">
<p>If you work with opaque tokens, you can test them as shown in the following code example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import static org.hamcrest.Matchers.is;
import org.junit.jupiter.api.Test;
import io.quarkus.test.common.http.TestHTTPEndpoint;
import io.quarkus.test.junit.QuarkusTest;
import io.quarkus.test.security.TestSecurity;
import io.quarkus.test.security.oidc.OidcSecurity;
import io.quarkus.test.security.oidc.TokenIntrospection;
import io.restassured.RestAssured;

@QuarkusTest
@TestHTTPEndpoint(ProtectedResource.class)
public class TestSecurityAuthTest {

    @Test
    @TestSecurity(user = "userOidc", roles = "viewer")
    @OidcSecurity(introspectionRequired = true,
        introspection = {
            @TokenIntrospection(key = "email", value = "user@gmail.com")
        }
    )
    public void testOidcWithClaimsUserInfoAndMetadata() {
        RestAssured.when().get("test-security-oidc-opaque-token").then()
                .body(is("userOidc:viewer:userOidc:viewer:user@gmail.com"));
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The  <code>ProtectedResource</code> class, which is used in this code example, might look like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import jakarta.inject.Inject;
import jakarta.ws.rs.GET;
import jakarta.ws.rs.Path;

import io.quarkus.oidc.TokenIntrospection;
import io.quarkus.security.Authenticated;
import io.quarkus.security.identity.SecurityIdentity;

@Path("/service")
@Authenticated
public class ProtectedResource {

    @Inject
    SecurityIdentity securityIdentity;
    @Inject
    TokenIntrospection introspection;

    @GET
    @Path("test-security-oidc-opaque-token")
    public String testSecurityOidcOpaqueToken() {
        return securityIdentity.getPrincipal().getName() + ":" + securityIdentity.getRoles().iterator().next()
            + ":" + introspection.getString("username")
            + ":" + introspection.getString("scope")
            + ":" + introspection.getString("email");
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>@TestSecurity</code>, <code>user</code>, and <code>roles</code> attributes are available as <code>TokenIntrospection</code>, <code>username</code>, and <code>scope</code> properties.
Use <code>io.quarkus.test.security.oidc.TokenIntrospection</code> to add the additional introspection response properties, such as an <code>email</code>, and so on.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>@TestSecurity</code> and <code>@OidcSecurity</code> can be combined in a meta-annotation, as outlined in the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">    @Retention(RetentionPolicy.RUNTIME)
    @Target({ ElementType.METHOD })
    @TestSecurity(user = "userOidc", roles = "viewer")
    @OidcSecurity(introspectionRequired = true,
        introspection = {
            @TokenIntrospection(key = "email", value = "user@gmail.com")
        }
    )
    public @interface TestSecurityMetaAnnotation {

    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is particularly useful if multiple test methods must use the same set of security settings.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="check-errors-in-the-logs"><a class="anchor" href="#check-errors-in-the-logs"></a>Check errors in the logs</h3>
<div class="paragraph">
<p>To see more details about token verification errors, enable <code>io.quarkus.oidc.runtime.OidcProvider</code> and <code>TRACE</code> level logging:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">quarkus.log.category."io.quarkus.oidc.runtime.OidcProvider".level=TRACE
quarkus.log.category."io.quarkus.oidc.runtime.OidcProvider".min-level=TRACE</code></pre>
</div>
</div>
<div class="paragraph">
<p>To see more details about <code>OidcProvider</code> client initialization errors, enable <code>io.quarkus.oidc.runtime.OidcRecorder</code> and <code>TRACE</code> level logging as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">quarkus.log.category."io.quarkus.oidc.runtime.OidcRecorder".level=TRACE
quarkus.log.category."io.quarkus.oidc.runtime.OidcRecorder".min-level=TRACE</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="external-and-internal-access-to-oidc-providers"><a class="anchor" href="#external-and-internal-access-to-oidc-providers"></a>External and internal access to OIDC providers</h3>
<div class="paragraph">
<p>The externally-accessible token of the OIDC provider and other endpoints might have different HTTP(S) URLs compared to the URLs that are auto-discovered or configured relative to the <code>quarkus.oidc.auth-server-url</code> internal URL.
For example, suppose your SPA acquires a token from an external token endpoint address and sends it to Quarkus as a bearer token.
In that case, the endpoint might report an issuer verification failure.</p>
</div>
<div class="paragraph">
<p>In such cases, if you work with Keycloak, start it with the <code>KEYCLOAK_FRONTEND_URL</code> system property set to the externally accessible base URL.
If you work with other OIDC providers, refer to your provider&#8217;s documentation.</p>
</div>
</div>
<div class="sect2">
<h3 id="using-client-id"><a class="anchor" href="#using-client-id"></a>Using the <code>client-id</code> property</h3>
<div class="paragraph">
<p>The <code>quarkus.oidc.client-id</code> property identifies the OIDC client that requested the current bearer token.
The OIDC client can be an SPA application running in a browser or a Quarkus <code>web-app</code> confidential client application propagating the access token to the Quarkus <code>service</code> application.</p>
</div>
<div class="paragraph">
<p>This property is required if the <code>service</code> application is expected to introspect the tokens remotely, which is always the case for the opaque tokens.
This property is optional for local JSON Web Token (JWT) verification only.</p>
</div>
<div class="paragraph">
<p>Setting the <code>quarkus.oidc.client-id</code> property is encouraged even if the endpoint does not require access to the remote introspection endpoint.
This is because when <code>client-id</code> is set, it can be used to verify the token audience.
It will also be included in logs when the token verification fails, enabling better traceability of tokens issued to specific clients and analysis over a longer period.</p>
</div>
<div class="paragraph">
<p>For example, if your OIDC provider sets a token audience, consider the following configuration pattern:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties"># Set client-id
quarkus.oidc.client-id=quarkus-app
# Token audience claim must contain 'quarkus-app'
quarkus.oidc.token.audience=${quarkus.oidc.client-id}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you set <code>quarkus.oidc.client-id</code>, but your endpoint does not require remote access to one of the OIDC provider endpoints (introspection, token acquisition, and so on), do not set a client secret with <code>quarkus.oidc.credentials</code> or similar properties because it will not be used.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Quarkus <code>web-app</code> applications always require the <code>quarkus.oidc.client-id</code> property.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="authentication-after-an-http-request-has-completed"><a class="anchor" href="#authentication-after-an-http-request-has-completed"></a>Authentication after an HTTP request has completed</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Sometimes, <code>SecurityIdentity</code> for a given token must be created when there is no active HTTP request context.
The <code>quarkus-oidc</code> extension provides <code>io.quarkus.oidc.TenantIdentityProvider</code> to convert a token to a <code>SecurityIdentity</code> instance.
For example, one situation when you must verify the token after the HTTP request has completed is when you are processing messages with <a href="vertx#event-bus">Vert.x event bus</a>.
The example below uses the 'product-order' message within different CDI request contexts.
Therefore, an injected <code>SecurityIdentity</code> would not correctly represent the verified identity and be anonymous.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.acme.quickstart.oidc;

import static jakarta.ws.rs.core.HttpHeaders.AUTHORIZATION;

import jakarta.inject.Inject;
import jakarta.ws.rs.HeaderParam;
import jakarta.ws.rs.POST;
import jakarta.ws.rs.Path;
import io.vertx.core.eventbus.EventBus;

@Path("order")
public class OrderResource {

    @Inject
    EventBus eventBus;

    @POST
    public void order(String product, @HeaderParam(AUTHORIZATION) String bearer) {
        String rawToken = bearer.substring("Bearer ".length()); <i class="conum" data-value="1"></i><b>(1)</b>
        eventBus.publish("product-order", new Product(product, rawToken));
    }

    public static class Product {
         public String product;
         public String customerAccessToken;
         public Product() {
         }
         public Product(String product, String customerAccessToken) {
             this.product = product;
             this.customerAccessToken = customerAccessToken;
         }
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>At this point, the token is not verified when proactive authentication is disabled.</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.acme.quickstart.oidc;

import jakarta.enterprise.context.ApplicationScoped;
import jakarta.inject.Inject;

import io.quarkus.oidc.AccessTokenCredential;
import io.quarkus.oidc.Tenant;
import io.quarkus.oidc.TenantIdentityProvider;
import io.quarkus.security.identity.SecurityIdentity;
import io.quarkus.vertx.ConsumeEvent;
import io.smallrye.common.annotation.Blocking;

@ApplicationScoped
public class OrderService {

    @Tenant("tenantId")
    @Inject
    TenantIdentityProvider identityProvider;

    @Inject
    TenantIdentityProvider defaultIdentityProvider; <i class="conum" data-value="1"></i><b>(1)</b>

    @Blocking
    @ConsumeEvent("product-order")
    void processOrder(OrderResource.Product product) {
        AccessTokenCredential tokenCredential = new AccessTokenCredential(product.customerAccessToken);
        SecurityIdentity securityIdentity = identityProvider.authenticate(tokenCredential).await().indefinitely(); <i class="conum" data-value="2"></i><b>(2)</b>
        ...
    }

}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>For the default tenant, the <code>Tenant</code> qualifier is optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Executes token verification and converts the token to a <code>SecurityIdentity</code>.</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>When the provider is used during an HTTP request, the tenant configuration can be resolved as described in
the <a href="security-openid-connect-multitenancy">Using OpenID Connect Multi-Tenancy</a> guide.
However, when there is no active HTTP request, you must select the tenant explicitly with the <code>io.quarkus.oidc.Tenant</code> qualifier.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p><a href="security-openid-connect-multitenancy#tenant-config-resolver">Dynamic tenant configuration resolution</a> is currently not supported.
Authentication that requires a dynamic tenant will fail.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="bearer-token-oidc-request-filters"><a class="anchor" href="#bearer-token-oidc-request-filters"></a>OIDC request filters</h2>
<div class="sectionbody">
<div class="paragraph">
<p>You can filter OIDC requests made by Quarkus to the OIDC provider by registering one or more <code>OidcRequestFilter</code> implementations, which can update or add new request headers, and log requests.
For more information, see <a href="security-oidc-code-flow-authentication#code-flow-oidc-request-filters">OIDC request filters</a>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="references"><a class="anchor" href="#references"></a>References</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p><a href="security-oidc-configuration-properties-reference">OIDC configuration properties</a></p>
</li>
<li>
<p><a href="security-oidc-bearer-token-authentication-tutorial">Protect a service application by using OIDC Bearer token authentication</a></p>
</li>
<li>
<p><a href="https://www.keycloak.org/documentation.html">Keycloak documentation</a></p>
</li>
<li>
<p><a href="https://openid.net/connect/">OpenID Connect</a></p>
</li>
<li>
<p><a href="https://tools.ietf.org/html/rfc7519">JSON Web Token</a></p>
</li>
<li>
<p><a href="security-openid-connect-client-reference">OpenID Connect and OAuth2 client and filters reference guide</a></p>
</li>
<li>
<p><a href="security-openid-connect-dev-services">Dev Services for Keycloak</a></p>
</li>
<li>
<p><a href="security-jwt-build">Sign and encrypt JWT tokens with SmallRye JWT Build</a></p>
</li>
<li>
<p><a href="security-authentication-mechanisms#oidc-jwt-oauth2-comparison">Choosing between OpenID Connect, SmallRye JWT, and OAuth2 authentication mechanisms</a></p>
</li>
<li>
<p><a href="security-authentication-mechanisms#combining-authentication-mechanisms">Combining authentication mechanisms</a></p>
</li>
<li>
<p><a href="security-overview">Quarkus Security overview</a></p>
</li>
<li>
<p><a href="security-keycloak-admin-client">Quarkus Keycloak Admin Client</a></p>
</li>
<li>
<p><a href="security-openid-connect-multitenancy">Using OpenID Connect Multi-Tenancy</a></p>
</li>
</ul>
</div>
</div>
</div>
    </div>
    <div class="grid__item width-4-12 width-12-12-m tocwrapper">
      <div class="hide-mobile toc"><ul class="sectlevel1">
<li><a href="#overview-of-the-bearer-token-authentication-mechanism-in-quarkus">Overview of the Bearer token authentication mechanism in Quarkus</a>
<ul class="sectlevel2">
<li><a href="#accessing-jwt-claims">Accessing JWT claims</a></li>
<li><a href="#bearer-token-user-info"><code>UserInfo</code></a></li>
<li><a href="#bearer-token-config-metadata">Configuration metadata</a></li>
<li><a href="#token-claims-and-security-identity-roles">Token claims and SecurityIdentity roles</a></li>
<li><a href="#token-scopes-and-security-identity-permissions">Token scopes and SecurityIdentity permissions</a></li>
<li><a href="#bearer-token-token-verification-introspection">Token verification and introspection</a></li>
<li><a href="#bearer-token-token-introspection-userinfo-cache">Token introspection and <code>UserInfo</code> cache</a></li>
<li><a href="#bearer-token-jwt-claim-verification">JSON Web Token claim verification</a></li>
<li><a href="#jose4j-validator">Jose4j Validator</a></li>
<li><a href="#single-page-applications">Single-page applications</a></li>
<li><a href="#cross-origin-resource-sharing">Cross-origin resource sharing</a></li>
<li><a href="#provider-endpoint-configuration">Provider endpoint configuration</a></li>
<li><a href="#token-propagation">Token propagation</a></li>
<li><a href="#jwt-token-certificate-chain">JWT token certificate chain</a></li>
<li><a href="#oidc-provider-client-authentication">OIDC provider client authentication</a></li>
<li><a href="#bearer-token-integration-testing">Testing</a></li>
<li><a href="#integration-testing-oidc-test-client"><code>OidcTestClient</code></a></li>
<li><a href="#check-errors-in-the-logs">Check errors in the logs</a></li>
<li><a href="#external-and-internal-access-to-oidc-providers">External and internal access to OIDC providers</a></li>
<li><a href="#using-client-id">Using the <code>client-id</code> property</a></li>
</ul>
</li>
<li><a href="#authentication-after-an-http-request-has-completed">Authentication after an HTTP request has completed</a></li>
<li><a href="#bearer-token-oidc-request-filters">OIDC request filters</a></li>
<li><a href="#references">References</a></li>
</ul></div>
    </div>
  </div>
  <h2>Related content</h2>
  <div class="grid-wrapper relations">
    <div class="grid__item width-6-12 width-12-12-m">
      <h3>On the same extensions</h3>
      <ul class="related-content">
      
        
        <li class="concepts"><a href="/guides/security-openid-connect-providers">Configuring Well-Known OpenID Connect Providers</a></li>
      
        
        <li class="howto"><a href="/guides/security-openid-connect-dev-services">Dev Services and Dev UI for OpenID Connect (OIDC)</a></li>
      
        
        <li class="reference"><a href="/guides/security-oidc-configuration-properties-reference">OpenID Connect (OIDC) configuration properties</a></li>
      
        
        <li class="concepts"><a href="/guides/security-oidc-code-flow-authentication">OpenID Connect authorization code flow mechanism for protecting web applications</a></li>
      
        
        <li class="tutorial"><a href="/guides/security-oidc-bearer-token-authentication-tutorial">Protect a service application by using OpenID Connect (OIDC) Bearer token authentication</a></li>
      
        
        <li class="tutorial"><a href="/guides/security-oidc-code-flow-authentication-tutorial">Protect a web application by using OpenID Connect (OIDC) authorization code flow</a></li>
      
        
        <li class="howto"><a href="/guides/security-keycloak-authorization">Using OpenID Connect (OIDC) and Keycloak to centralize authorization</a></li>
      
        
        <li class="howto"><a href="/guides/security-openid-connect-multitenancy">Using OpenID Connect (OIDC) multitenancy</a></li>
      </ul>
    </div>
    <div class="grid__item width-6-12 width-12-12-m">
      <h3>On the same topics</h3>
      <ul class="related-content">
      
        
        <li class="tutorial"><a href="/guides/security-oidc-bearer-token-authentication-tutorial">Protect a service application by using OpenID Connect (OIDC) Bearer token authentication</a></li>
      
        
        <li class="concepts"><a href="/guides/security-oidc-code-flow-authentication">OpenID Connect authorization code flow mechanism for protecting web applications</a></li>
      
        
        <li class="howto"><a href="/guides/security-keycloak-authorization">Using OpenID Connect (OIDC) and Keycloak to centralize authorization</a></li>
      
        
        <li class="howto"><a href="/guides/security-openid-connect-dev-services">Dev Services and Dev UI for OpenID Connect (OIDC)</a></li>
      
        
        <li class="tutorial"><a href="/guides/security-oidc-code-flow-authentication-tutorial">Protect a web application by using OpenID Connect (OIDC) authorization code flow</a></li>
      
        
        <li class="guide"><a href="/guides/security-keycloak-admin-client">Using Keycloak Admin Client</a></li>
      
        
        <li class="concepts"><a href="/guides/security-authentication-mechanisms">Authentication mechanisms in Quarkus</a></li>
      
        
        <li class="concepts"><a href="/guides/security-basic-authentication">Basic authentication</a></li>
      
        
        <li class="concepts"><a href="/guides/security-openid-connect-providers">Configuring Well-Known OpenID Connect Providers</a></li>
      
        
        <li class="howto"><a href="/guides/security-basic-authentication-howto">Enable Basic authentication</a></li>
      
        
        <li class="tutorial"><a href="/guides/security-getting-started-tutorial">Getting started with Security by using Basic authentication and Jakarta Persistence</a></li>
      
        
        <li class="reference"><a href="/guides/security-openid-connect-client-reference">OpenID Connect (OIDC) and OAuth2 client and filters</a></li>
      
        
        <li class="reference"><a href="/guides/security-openid-connect-client-registration">OpenID Connect (OIDC) and OAuth2 dynamic client registration</a></li>
      
        
        <li class="reference"><a href="/guides/security-oidc-configuration-properties-reference">OpenID Connect (OIDC) configuration properties</a></li>
      
        
        <li class="tutorial"><a href="/guides/security-openid-connect-client">OpenID Connect client and token propagation quickstart</a></li>
      
        
        <li class="concepts"><a href="/guides/security-proactive-authentication">Proactive authentication</a></li>
      
        
        <li class="howto"><a href="/guides/security-openid-connect-multitenancy">Using OpenID Connect (OIDC) multitenancy</a></li>
      
        
        <li class="reference"><a href="/guides/security-authorize-web-endpoints-reference">Authorization of web endpoints</a></li>
      
        
        <li class="guide"><a href="/guides/security-jwt-build">Build, Sign and Encrypt JSON Web Tokens</a></li>
      
        
        <li class="guide"><a href="/guides/security-csrf-prevention">Cross-Site Request Forgery Prevention</a></li>
      </ul>
    </div>
    </div>
  </div>

  </div>

  <div class="content project-footer">
  <div class="footer-section">
    <div class="logo-wrapper">
      <a href="/"><img src="/assets/images/quarkus_logo_horizontal_rgb_reverse.svg" class="project-logo" title="Quarkus"></a>
    </div>
  </div>
  <div class="grid-wrapper">
    <p class="grid__item width-3-12">Quarkus is open. All dependencies of this project are available under the <a href='https://www.apache.org/licenses/LICENSE-2.0' target='_blank'>Apache Software License 2.0</a> or compatible license.<br /><br />This website was built with <a href='https://jekyllrb.com/' target='_blank'>Jekyll</a>, is hosted on <a href='https://pages.github.com/' target='_blank'>GitHub Pages</a> and is completely open source. If you want to make it better, <a href='https://github.com/quarkusio/quarkusio.github.io' target='_blank'>fork the website</a> and show us what you’ve got.</p>

    
      <div class="width-1-12 project-links">
        <span>Navigation</span>
        <ul class="footer-links">
          
          
            <li><a href="/" target="_blank">Home</a></li>
          
          
          
            <li><a href="/about" target="_blank">About</a></li>
          
          
          
            <li><a href="/blog" target="_blank">Blog</a></li>
          
          
          
            <li><a href="/insights" target="_blank">Podcast</a></li>
          
          
          
            <li><a href="/events" target="_blank">Events</a></li>
          
          
          
            <li><a href="/newsletter" target="_blank">Newsletter</a></li>
          
          
          
            <li><a href="https://github.com/orgs/quarkusio/projects/13/views/1" target="_blank">Roadmap</a></li>
          
          
          
            <li><a href="/security" target="_blank">Security&nbsp;policy</a></li>
          
          
          
            <li><a href="/usage" target="_blank">Usage</a></li>
          
          
          
            <li><a href="/brand" target="_blank">Brand</a></li>
          
          
          
            <li><a href="/desktopwallpapers" target="_blank">Wallpapers</a></li>
          
          
        </ul>
      </div>
    
      <div class="width-1-12 project-links">
        <span>Follow Us</span>
        <ul class="footer-links">
          
          
            <li><a href="https://x.com/quarkusio" target="_blank">X</a></li>
          
          
          
            <li><a rel="me" href="https://fosstodon.org/@quarkusio" target="_blank">Mastodon</a></li>
            
          
          
            <li><a href="https://www.facebook.com/quarkusio" target="_blank">Facebook</a></li>
          
          
          
            <li><a href="https://www.linkedin.com/company/quarkusio/" target="_blank">Linkedin</a></li>
          
          
          
            <li><a href="https://www.youtube.com/channel/UCaW8QG_QoIk_FnjLgr5eOqg" target="_blank">Youtube</a></li>
          
          
          
            <li><a href="https://github.com/quarkusio" target="_blank">GitHub</a></li>
          
          
        </ul>
      </div>
    
      <div class="width-2-12 project-links">
        <span>Get Help</span>
        <ul class="footer-links">
          
          
            <li><a href="/support" target="_blank">Support</a></li>
          
          
          
            <li><a href="/guides" target="_blank">Guides</a></li>
          
          
          
            <li><a href="/faq" target="_blank">FAQ</a></li>
          
          
          
            <li><a href="/get-started" target="_blank">Get Started</a></li>
          
          
          
            <li><a href="https://stackoverflow.com/questions/tagged/quarkus" target="_blank">Stack Overflow</a></li>
          
          
          
            <li><a href="https://github.com/quarkusio/quarkus/discussions" target="_blank">Discussions</a></li>
          
          
          
            <li><a href="https://groups.google.com/forum/#!forum/quarkus-dev" target="_blank">Development mailing list</a></li>
          
          
        </ul>
      </div>
    
      <div class="width-1-12 project-links">
        <span>Languages</span>
        <ul class="footer-links">
          
          
            <li><a href="https://quarkus.io/" target="_blank">English</a></li>
          
          
          
            <li><a href="https://pt.quarkus.io/" target="_blank">Português&nbsp;(Brasileiro)</a></li>
          
          
          
            <li><a href="https://es.quarkus.io/" target="_blank">Español</a></li>
          
          
          
            <li><a href="https://cn.quarkus.io/" target="_blank">简体中文</a></li>
          
          
          
            <li><a href="https://ja.quarkus.io/" target="_blank">日本語</a></li>
          
          
        </ul>
      </div>
    

    
      <div class="width-4-12 more-links">
        <span>Quarkus is made of community projects</span>
        <ul class="footer-links">
          
            <li><a blah href="https://vertx.io/" target="_blank">Eclipse Vert.x</a></li>
          
            <li><a blah href="https://smallrye.io" target="_blank">SmallRye</a></li>
          
            <li><a blah href="https://hibernate.org" target="_blank">Hibernate</a></li>
          
            <li><a blah href="https://netty.io" target="_blank">Netty</a></li>
          
            <li><a blah href="https://resteasy.github.io" target="_blank">RESTEasy</a></li>
          
            <li><a blah href="https://camel.apache.org" target="_blank">Apache Camel</a></li>
          
            <li><a blah href="https://microprofile.io" target="_blank">Eclipse MicroProfile</a></li>
          
            <li><a blah href="https://code.quarkus.io/" target="_blank">And many more...</a></li>
          
        </ul>
      </div>
    
  </div>
</div>

  <div class="content redhat-footer">
  <div class="grid-wrapper">
    <span class="licence">
      <i class="fab fa-creative-commons"></i><i class="fab fa-creative-commons-by"></i> <a href="https://creativecommons.org/licenses/by/3.0/" target="_blank">CC by 3.0</a> | <a href="https://www.redhat.com/en/about/privacy-policy">Privacy Policy</a>
    </span>
    <span class="redhat">
      Sponsored by
    </span>
    <span class="redhat-logo">
      <a href="https://www.redhat.com/" target="_blank"><img src="/assets/images/redhat_reversed.svg"></a>
    </span>
  </div>
</div>


  <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.4/jquery.min.js" integrity="sha384-8gBf6Y4YYq7Jx97PIqmTwLPin4hxIzQw5aDmUg/DDhul9fFpbbLcLh3nTIIDJKhx" crossorigin="anonymous"></script>
  <script type="text/javascript" src="/assets/javascript/mobile-nav.js"></script>
  <script type="text/javascript" src="/assets/javascript/scroll-down.js"></script>
  <script src="/assets/javascript/satellite.js" type="text/javascript"></script>
  <script src="/guides/javascript/config.js" type="text/javascript"></script>
  <script src="/assets/javascript/guides-version-dropdown.js" type="text/javascript"></script>
  <script src="/assets/javascript/back-to-top.js" type="text/javascript"></script>
  <script src="/assets/javascript/clipboard.min.js" type="text/javascript"></script>
  <script src="/assets/javascript/copy.js" type="text/javascript"></script>
  <script src="/assets/javascript/asciidoc-tabs.js" type="text/javascript"></script>
  <script src="/assets/javascript/future-date.js" type="text/javascript"></script>
</body>

</html>
